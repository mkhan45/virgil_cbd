type CBDType {
    case I32;
    case U32;
    case F32;
    case Bot;

    def toString() -> string {
        match (this) {
            I32 => return "i32";
            U32 => return "u32";
            F32 => return "f32";
            Bot => return "⊥";
        }
    }
}

component CBDTypes {
    def intrinsic_type(fn_name: string) -> (Array<CBDType>, CBDType) {
        if (Strings.equal(fn_name, "readImmULEB32")) return ([], CBDType.U32);
        if (Strings.equal(fn_name, "readImmILEB32")) return ([], CBDType.I32);

        if (Strings.equal(fn_name, "pop_i32")) return ([], CBDType.I32);
        if (Strings.equal(fn_name, "pop_f32")) return ([], CBDType.F32);

        return (null, CBDType.Bot);
    }
}

class EffectResult(stack_delta: int, ctl_xfer: bool) {}

component CBDEffects {
    def run_fx(fx: Vector<CBDEffect>) -> EffectResult {
        var sd = 0;
        var ctl = false;
        for (i < fx.length) {
            if (fx[i] == CBDEffect.Push) sd += 1;
            if (fx[i] == CBDEffect.Pop) sd -= 1;
            if (fx[i] == CBDEffect.CtlXfer) ctl = true;
        }
        return EffectResult.new(sd, ctl);
    }
}

type CBDEffect {
    // TODO: type push and pop?
    case Push;
    case Pop;
    case CtlXfer;
    case None;

    def is_stack() -> bool {
        match (this) {
            Push => return true;
            Pop => return true;
            _ => return false;
        }
    }

    // this should probably be specific to tier
    def is_sidetable() -> bool {
        match (this) {
            CtlXfer => return true;
            _ => return false;
        }
    }

    def toString() -> string {
        match (this) {
            Push => return "push";
            Pop => return "pop";
            CtlXfer => return "ctl";
            None => return "none";
        }
    }
}

class SSADCtx {
    var body: SSAD;
    var static: HashMap<string, bool>;
    var types: HashMap<string, CBDType>;
    var effects: HashMap<string, CBDEffect>; // should it be a list?

    new(body) {
        static = HashMap.new(Strings.hash, Strings.equal);
        getStatic(body);

        types = HashMap.new(Strings.hash, Strings.equal);
        effects = HashMap.new(Strings.hash, Strings.equal);
        getTypes(body);
    }

    def getStatic(node: SSAD) {
        match (node) {
            LetApp(n, f, as, rest) => {
                def f_static = Strings.startsWith(f, "f_")
                    || Strings.startsWith(f, "m_")
                    || Strings.startsWith(f, "read")
                    || Strings.equal(f, "id");
                var as_static = true;
                for (a in as) as_static &= static[a]; // a ∈ static because all args are already defined
                static[n] = f_static && as_static;
                getStatic(rest);
            }
            LetLit(n, l, t, rest) => {
                static[n] = true;
                getStatic(rest);
            }
            If(c, t, e, phis, rest) => {
                getStatic(t);
                getStatic(e);
                for (p in phis) static[p] = static[c];
                getStatic(rest);
            }
            Void => return;
            Injected(i, rest) => getStatic(rest);
            Final(v) => return;
        }
    }

    def getTypes(node: SSAD) {
        match (node) {
	        LetApp(n, f, as, rest) => {
                // don't bother checking args
                if (Strings.equal(f, "id")) {
                    types[n] = types[as[0]];
                } else {
                    def f_type = CBDTypes.intrinsic_type(f);
                    types[n] = f_type.1;
                }

                // could consider collecting effects from args
                effects[n] = CBDEffect.None;
                if (Strings.startsWith(f, "push")) effects[n] = CBDEffect.Push;
                if (Strings.startsWith(f, "pop")) effects[n] = CBDEffect.Pop;
                if (Strings.equal(f, "doBranch")) effects[n] = CBDEffect.CtlXfer;
                if (Strings.equal(f, "doFallthru")) effects[n] = CBDEffect.CtlXfer;

                getTypes(rest);
            }
            LetLit(n, l, t, rest) => {
                effects[n] = CBDEffect.None;
                var tp: CBDType = CBDType.Bot;
                if (Strings.equal(t, "int")) tp = CBDType.I32;
                if (Strings.equal(t, "float")) tp = CBDType.F32;
                types[n] = tp;
                getTypes(rest);
            }
            If(c, t, e, phis, rest) => {
                // TODO: give phis types
                getTypes(t);
                getTypes(e);
                getTypes(rest);
            }
            Void => return;
            Injected(i, rest) => getStatic(rest);
            Final(v) => return;
        }
    }

    def collectEffects(node: SSAD, buf: Vector<CBDEffect>) {
        match (node) {
            Final(v) => return;
            Void => return;
            Injected(i, rest) => collectEffects(rest, buf);
            LetLit(n, l, t, rest) => collectEffects(rest, buf);
            LetApp(n, f, as, rest) => {
                if (effects[n] != CBDEffect.None) buf.put(effects[n]);
                collectEffects(rest, buf);
            }
            If(c, t, e, phis, rest) => {
                // TODO: t and e should have the same effects?
                collectEffects(t, buf);
                // collectEffects(e, buf);
                collectEffects(rest, buf);
            }
        }
    }
}
