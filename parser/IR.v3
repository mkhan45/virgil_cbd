type SSAD {
    case LetApp(n: string, f: string, args: Array<string>, rest: SSAD);
    case If(cond: string, then: SSAD, els: SSAD);
    case Void;
    case Injected(inj: string);
    case Final(v: string);
}

component SSAD_IR {
    var counter = 0;
    def uid() -> string {
        def res = Strings.format1("var%i", counter);
	counter += 1;
	return res;
    }
    def uidl(l: string) -> string {
        def res = Strings.format2("%s%i", l, counter);
	counter += 1;
	return res;
    }

    def from_virgil(stmt: VirgilStmt) -> SSAD {
	match (stmt) {
            Block(ss) => {
                var res = SSAD.Void;
		return res;
	    }
	    Expr(_) => return SSAD.Void;
	    Return(e) => {
	        def n = uidl("ret");
                return from_virgil_expr(n, e, SSAD.Final(n));
	    }
	    _ => return SSAD.Void; // TODO
	}
    }

    def from_virgil_expr(name: string, expr: VirgilExpr, rest: SSAD) -> SSAD {
	match (expr) {
            AppExpr(f, args) => {
		def arg_names = Arrays.map(args, fun (a: VirgilExpr) => uidl("arg"));
		var res: SSAD = SSAD.LetApp(name, f, arg_names, rest);
		for (a < args.length) {
		    res = from_virgil_expr(arg_names[a], args[a], res);
		}
		return res;
            }
	    BinOpExpr(o, l, r) => {
	        def ln = uidl("left");
	        def rn = uidl("right");
		return from_virgil_expr(ln, l, 
				from_virgil_expr(rn, r,
					SSAD.LetApp(name, o, [ln, rn], rest)));
	    }
	    Literal(tipe, string_rep) => {
                return SSAD.LetApp(name, "lit", [string_rep], rest); // TODO: literals, types?
	    }
	    VarExpr(v) => {
                return SSAD.LetApp(name, "id", [v], rest);
            }
	    IfExpr(c, t, e) => {
		def cn = uidl("cond");
		def tv = uidl("tv");
		def ev = uidl("ev");
		return SSAD.If(cn, from_virgil_expr(tv, t, rest), from_virgil_expr(ev, e, rest));
	    }
        }
    }
}
