// GENERATED BY ValidatorGen.v3
def UNREACHABLE() {
	// eff00 -- static: no, type: ⊥, effect: ctl

	def eff00 = trapUnreachable();
}
def LOCAL_GET() {
	// arg53 -- static: yes, type: u32, effect: none
// tv2 -- static: yes, type: ⊥, effect: none
// arg61 -- static: yes, type: u32, effect: none
// val5 -- static: no, type: ⊥, effect: none
// eff18 -- static: no, type: ⊥, effect: push
// arg27 -- static: yes, type: ⊥, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg36 -- static: no, type: ⊥, effect: none
// arg44 -- static: yes, type: ⊥, effect: none

	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val5 = getLocal(tv2, index0);
	def eff18 = push_Value(tv2, val5);
}
def LOCAL_SET() {
	// eff98 -- static: no, type: ⊥, effect: state
// arg141 -- static: yes, type: u32, effect: none
// tv2 -- static: yes, type: ⊥, effect: none
// arg107 -- static: yes, type: ⊥, effect: none
// val4 -- static: no, type: ⊥, effect: pop
// arg116 -- static: yes, type: u32, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg125 -- static: no, type: ⊥, effect: none
// arg133 -- static: yes, type: ⊥, effect: none

	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val4 = pop_Value(tv2);
	def eff98 = setLocal(tv2, index0, val4);
}
def LOCAL_TEE() {
	// arg163 -- static: yes, type: ⊥, effect: none
// tv2 -- static: yes, type: ⊥, effect: none
// arg1010 -- static: yes, type: ⊥, effect: none
// arg171 -- static: yes, type: u32, effect: none
// eff911 -- static: no, type: ⊥, effect: push
// arg119 -- static: no, type: ⊥, effect: none
// eff128 -- static: no, type: ⊥, effect: state
// val4 -- static: no, type: ⊥, effect: pop
// arg137 -- static: yes, type: ⊥, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg146 -- static: yes, type: u32, effect: none
// arg155 -- static: no, type: ⊥, effect: none

	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val4 = pop_Value(tv2);
	def eff128 = setLocal(tv2, index0, val4);
	def eff911 = push_Value(tv2, val4);
}
def GLOBAL_GET() {
	// arg163 -- static: yes, type: u32, effect: none
// tv2 -- static: yes, type: ⊥, effect: none
// arg171 -- static: yes, type: u32, effect: none
// val5 -- static: no, type: ⊥, effect: none
// eff128 -- static: no, type: ⊥, effect: push
// arg137 -- static: yes, type: ⊥, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg146 -- static: no, type: ⊥, effect: none
// arg154 -- static: yes, type: ⊥, effect: none

	def index0 = readImmULEB32();
	def tv2 = m_getGlobalType(index0);
	def val5 = getGlobal(tv2, index0);
	def eff128 = push_Value(tv2, val5);
}
def GLOBAL_SET() {
	// eff98 -- static: no, type: ⊥, effect: state
// arg141 -- static: yes, type: u32, effect: none
// tv2 -- static: yes, type: ⊥, effect: none
// arg107 -- static: yes, type: ⊥, effect: none
// val4 -- static: no, type: ⊥, effect: pop
// arg116 -- static: yes, type: u32, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg125 -- static: no, type: ⊥, effect: none
// arg133 -- static: yes, type: ⊥, effect: none

	def index0 = readImmULEB32();
	def tv2 = m_getGlobalType(index0);
	def val4 = pop_Value(tv2);
	def eff98 = setGlobal(tv2, index0, val4);
}
def TABLE_GET() {
	// index9 -- static: no, type: ⊥, effect: pop
// val12 -- static: no, type: ⊥, effect: none
// table_index0 -- static: yes, type: u32, effect: ctl
// arg181 -- static: yes, type: u32, effect: none
// eff108 -- static: no, type: ⊥, effect: push
// val6 -- static: no, type: ⊥, effect: none
// index3 -- static: no, type: ⊥, effect: pop
// arg117 -- static: no, type: ⊥, effect: none
// arg1513 -- static: no, type: ⊥, effect: none
// arg125 -- static: yes, type: u32, effect: none
// arg1710 -- static: no, type: ⊥, effect: none
// arg1611 -- static: yes, type: u32, effect: none
// eff1414 -- static: no, type: ⊥, effect: push
// arg134 -- static: no, type: ⊥, effect: none
// cond92 -- static: yes, type: ⊥, effect: none

	def table_index0 = readImmULEB32();
	def cond92 = m_isTable64(table_index0);
	def if15 = emitIfStatic(cond92);
	def index3 = pop_u64();
	def val6 = mach_readTable64(table_index0, index3);
	def eff108 = push_Object(val6);
	def else16 = emitElse();
	def index9 = pop_u32();
	def val12 = mach_readTable32(table_index0, index9);
	def eff1414 = push_Object(val12);
	def endBrace17 = emitEnd();
}
def TABLE_SET() {
	// arg271 -- static: yes, type: u32, effect: none
// val9 -- static: no, type: ⊥, effect: pop
// table_index0 -- static: yes, type: u32, effect: ctl
// index10 -- static: no, type: ⊥, effect: pop
// arg207 -- static: yes, type: u32, effect: none
// index4 -- static: no, type: ⊥, effect: pop
// arg216 -- static: no, type: ⊥, effect: none
// val3 -- static: no, type: ⊥, effect: pop
// arg225 -- static: no, type: ⊥, effect: none
// arg2611 -- static: no, type: ⊥, effect: none
// arg2512 -- static: no, type: ⊥, effect: none
// arg2413 -- static: yes, type: u32, effect: none
// cond182 -- static: yes, type: ⊥, effect: none
// eff2314 -- static: no, type: ⊥, effect: none
// eff198 -- static: no, type: ⊥, effect: state

	def table_index0 = readImmULEB32();
	def cond182 = m_isTable64(table_index0);
	def if15 = emitIfStatic(cond182);
	def val3 = pop_Object();
	def index4 = pop_u64();
	def eff198 = mach_writeTable64(table_index0, index4, val3);
	def else16 = emitElse();
	def val9 = pop_Object();
	def index10 = pop_u32();
	def endBrace17 = emitEnd();
}
def CALL() {
	// arg196 -- static: yes, type: ⊥, effect: none
// target4 -- static: no, type: ⊥, effect: none
// arg205 -- static: no, type: ⊥, effect: none
// sig2 -- static: yes, type: ⊥, effect: none
// index0 -- static: yes, type: u32, effect: ctl
// arg213 -- static: yes, type: u32, effect: none
// arg221 -- static: yes, type: u32, effect: none
// eff187 -- static: no, type: ⊥, effect: ctl

	def index0 = readImmULEB32();
	def sig2 = m_getFuncSignature(index0);
	def target4 = i_getFunction(index0);
	def eff187 = doCall(sig2, target4);
}
def CALL_INDIRECT() {
	// arg1111 -- static: no, type: ⊥, effect: none
// arg1012 -- static: yes, type: ⊥, effect: none
// arg1719 -- static: no, type: ⊥, effect: none
// ret1521 -- static: no, type: ⊥, effect: ctl
// table_index1 -- static: yes, type: u32, effect: ctl
// arg1916 -- static: yes, type: ⊥, effect: none
// arg1817 -- static: yes, type: u32, effect: none
// arg129 -- static: yes, type: u32, effect: none
// target10 -- static: no, type: ⊥, effect: none
// sig_index0 -- static: yes, type: u32, effect: ctl
// sig3 -- static: yes, type: ⊥, effect: none
// arg138 -- static: yes, type: ⊥, effect: none
// func_index14 -- static: no, type: ⊥, effect: pop
// arg214 -- static: yes, type: u32, effect: none
// cond85 -- static: yes, type: ⊥, effect: none
// func_index6 -- static: no, type: ⊥, effect: pop
// arg147 -- static: no, type: ⊥, effect: none
// arg222 -- static: yes, type: u32, effect: none
// arg1620 -- static: yes, type: ⊥, effect: none
// arg2015 -- static: no, type: ⊥, effect: none
// ret913 -- static: no, type: ⊥, effect: ctl
// target18 -- static: no, type: ⊥, effect: none

	def sig_index0 = readImmULEB32();
	def table_index1 = readImmULEB32();
	def sig3 = m_getSignature(sig_index0);
	def cond85 = m_isTable64(table_index1);
	def if22 = emitIfStatic(cond85);
	def func_index6 = pop_u64();
	def target10 = i_getTableFunction64(table_index1, sig3, func_index6);
	def ret913 = doCall(sig3, target10);
	def else23 = emitElse();
	def func_index14 = pop_u32();
	def target18 = i_getTableFunction32(table_index1, sig3, func_index14);
	def ret1521 = doCall(sig3, target18);
	def endBrace24 = emitEnd();
}
def I32_CONST() {
	// arg261 -- static: no, type: i32, effect: none
// x0 -- static: yes, type: i32, effect: ctl
// eff252 -- static: no, type: ⊥, effect: push

	def x0 = readImmILEB32();
	def arg261 = rtcast_i32(x0);
	def eff252 = push_i32(arg261);
}
def I32_ADD() {
	// x0 -- static: no, type: i32, effect: pop
// y1 -- static: no, type: i32, effect: pop
// left52 -- static: no, type: i32, effect: none
// r4 -- static: no, type: i32, effect: none
// eff36 -- static: no, type: ⊥, effect: push
// right63 -- static: no, type: i32, effect: none
// arg45 -- static: no, type: ⊥, effect: none

	def x0 = pop_i32();
	def y1 = pop_i32();
	def r4 = EmitOpI32.plus(x0, y1);
	def eff36 = push_i32(r4);
}
def I32_SUB() {
	// eff76 -- static: no, type: ⊥, effect: push
// arg85 -- static: no, type: ⊥, effect: none
// x0 -- static: no, type: i32, effect: pop
// y1 -- static: no, type: i32, effect: pop
// left92 -- static: no, type: i32, effect: none
// r4 -- static: no, type: i32, effect: none
// right103 -- static: no, type: i32, effect: none

	def x0 = pop_i32();
	def y1 = pop_i32();
	def r4 = EmitOpI32.minus(y1, x0);
	def eff76 = push_i32(r4);
}
def I32_EQZ() {
	// eff85 -- static: no, type: ⊥, effect: push
// right132 -- static: yes, type: i32, effect: none
// arg94 -- static: no, type: i32, effect: none
// rtcast13 -- static: no, type: i32, effect: none
// x0 -- static: no, type: i32, effect: pop
// eff107 -- static: no, type: ⊥, effect: push
// arg116 -- static: no, type: i32, effect: none
// lit9 -- static: yes, type: ⊥, effect: none
// cond73 -- static: no, type: i32, effect: none
// left121 -- static: no, type: i32, effect: none
// lit11 -- static: yes, type: ⊥, effect: none

	def x0 = pop_i32();
	def right132 : int = 0;
	def rtcast13 = rtcast_i32(right132);
	def cond73 = EmitOpI32.equals(x0, rtcast13);
	def if8 = emitIf(cond73);
	def lit9 : int = 1;
	def arg94 = rtcast_i32(lit9);
	def eff85 = push_i32(arg94);
	def else10 = emitElse();
	def lit11 : int = 0;
	def arg116 = rtcast_i32(lit11);
	def eff107 = push_i32(arg116);
	def endBrace12 = emitEnd();
}
def F32_MAX() {
	// cond1611 -- static: no, type: f32, effect: none
// right244 -- static: no, type: f32, effect: none
// cond225 -- static: no, type: f32, effect: none
// left206 -- static: no, type: f32, effect: none
// right1810 -- static: no, type: f32, effect: none
// cond198 -- static: no, type: f32, effect: none
// left179 -- static: no, type: f32, effect: none
// left233 -- static: no, type: f32, effect: none
// right217 -- static: no, type: f32, effect: none
// arg1512 -- static: no, type: f32, effect: none
// eff1413 -- static: no, type: ⊥, effect: push
// a1 -- static: no, type: f32, effect: pop
// r2 -- static: no, type: f32, effect: none
// b0 -- static: no, type: f32, effect: pop

	def b0 = pop_f32();
	def a1 = pop_f32();
	def cond225 = EmitOpF32.gt(a1, b0);
	def if14 = emitIf(cond225);
	def else15 = emitElse();
	def endBrace16 = emitEnd();
	def cond198 = EmitOpF32.equals(a1, b0);
	def if17 = emitIf(cond198);
	def else18 = emitElse();
	def endBrace19 = emitEnd();
	def cond1611 = EmitOpF32.gt(b0, a1);
	def if20 = emitIf(cond1611);
	def else21 = emitElse();
	def endBrace22 = emitEnd();
	def eff1413 = push_f32(a1);
}
def BR() {
	// arg261 -- static: yes, type: u32, effect: none
// ret235 -- static: no, type: i32, effect: none
// label2 -- static: yes, type: ⊥, effect: none
// depth0 -- static: yes, type: u32, effect: ctl
// eff244 -- static: no, type: ⊥, effect: ctl
// arg253 -- static: yes, type: ⊥, effect: none

	def depth0 = readImmULEB32();
	def label2 = f_getLabel(depth0);
	def eff244 = doBranch(label2);
	return void;
}
def BR_IF() {
	// cond3 -- static: no, type: i32, effect: pop
// rtcast13 -- static: no, type: i32, effect: none
// cond66 -- static: no, type: i32, effect: none
// left104 -- static: no, type: i32, effect: none
// label2 -- static: yes, type: ⊥, effect: none
// depth0 -- static: yes, type: u32, effect: ctl
// right115 -- static: yes, type: i32, effect: none
// eff78 -- static: no, type: ⊥, effect: ctl
// arg121 -- static: yes, type: u32, effect: none
// arg87 -- static: yes, type: ⊥, effect: none
// eff99 -- static: no, type: ⊥, effect: ctl

	def depth0 = readImmULEB32();
	def label2 = f_getLabel(depth0);
	def cond3 = pop_i32();
	def right115 : int = 0;
	def rtcast13 = rtcast_i32(right115);
	def cond66 = EmitOpI32.not_equals(cond3, rtcast13);
	def if10 = emitIf(cond66);
	def eff78 = doBranch(label2);
	def else11 = emitElse();
	def eff99 = doFallThru();
	def endBrace12 = emitEnd();
}
def BLOCK() {
	// arg151 -- static: no, type: ⊥, effect: none
// bt0 -- static: no, type: ⊥, effect: ctl
// eff142 -- static: no, type: ⊥, effect: ctl

	def bt0 = readImmBlockType();
	def eff142 = doBlock(bt0);
}
def LOOP() {
	// eff32 -- static: no, type: ⊥, effect: ctl
// arg41 -- static: no, type: ⊥, effect: none
// bt0 -- static: no, type: ⊥, effect: ctl

	def bt0 = readImmBlockType();
	def eff32 = doLoop(bt0);
}
def TRY() {
	// eff32 -- static: no, type: ⊥, effect: ctl
// arg41 -- static: no, type: ⊥, effect: none
// bt0 -- static: no, type: ⊥, effect: ctl

	def bt0 = readImmBlockType();
	def eff32 = doTry(bt0);
}
def IF() {
	// bt0 -- static: no, type: ⊥, effect: ctl
// cond36 -- static: no, type: i32, effect: none
// rtcast13 -- static: no, type: i32, effect: none
// cond1 -- static: no, type: i32, effect: pop
// arg92 -- static: yes, type: ⊥, effect: none
// left74 -- static: no, type: i32, effect: none
// label3 -- static: yes, type: ⊥, effect: none
// eff48 -- static: no, type: ⊥, effect: ctl
// arg57 -- static: yes, type: ⊥, effect: none
// eff69 -- static: no, type: ⊥, effect: ctl
// right85 -- static: yes, type: i32, effect: none

	def bt0 = readImmBlockType();
	def cond1 = pop_i32();
	def arg92 : u32 = 0;
	def label3 = f_getLabel(arg92);
	def right85 : int = 0;
	def rtcast13 = rtcast_i32(right85);
	def cond36 = EmitOpI32.equals(cond1, rtcast13);
	def if10 = emitIf(cond36);
	def eff48 = doBranch(label3);
	def else11 = emitElse();
	def eff69 = doFallThru();
	def endBrace12 = emitEnd();
}
def ELSE() {
	// arg152 -- static: yes, type: ⊥, effect: none
// arg160 -- static: yes, type: ⊥, effect: none
// label1 -- static: yes, type: ⊥, effect: none
// eff143 -- static: no, type: ⊥, effect: ctl

	def arg160 : u32 = 0;
	def label1 = f_getLabel(arg160);
	def eff143 = doBranch(label1);
}
def END() {
	// eff52 -- static: no, type: ⊥, effect: ctl
// eff60 -- static: no, type: ⊥, effect: ctl
// cond41 -- static: yes, type: ⊥, effect: none

	def eff60 = doEnd();
	def cond41 = f_isAtEnd();
	def if3 = emitIfStatic(cond41);
	def eff52 = doReturn();
	def else4 = emitElse();
	def endBrace5 = emitEnd();
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  DISPATCH_TABLE[Opcode.UNREACHABLE.code] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.LOCAL_GET.code] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.code] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.code] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.code] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.code] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.code] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.code] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.code] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.code] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.I32_CONST.code] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.code] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.code] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_EQZ.code] = I32_EQZ;
  DISPATCH_TABLE[Opcode.F32_MAX.code] = F32_MAX;
  DISPATCH_TABLE[Opcode.BR.code] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.code] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.code] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.code] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.code] = TRY;
  DISPATCH_TABLE[Opcode.IF.code] = IF;
  DISPATCH_TABLE[Opcode.ELSE.code] = ELSE;
  DISPATCH_TABLE[Opcode.END.code] = END;
  return DISPATCH_TABLE;
}

var codeptr: CodePtr;
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>; // local varnames are just local_$i
var stack: ArrayStack<(string, TypeVar)>;

var code_builder: StringBuilder;
var cnt: int = 0;

def uidl(l: string) -> string {
    def r = Strings.format2<string, int>("%s_%d", l, cnt);
    cnt += 1;
    return r;
}

def assert(b: bool) {
    if (!b) {
        System.puts("assert fail :(\n");
	return [][1];
    }
}

type CompilerCtlEntry {
    case Block(end_pc: int, label_name: string);
    case Loop(start_pc: int, end_pc: int, label_name: string);
    case None;
}
var ctls: Array<CompilerCtlEntry>;
var ctl_stack: ArrayStack<int>;

// Constants
def HAS_MEM_INDEX = 0x40u8;

// Types.
// class Object { }
component EmitOpI32 {
    def plus(lhs: (string, TypeVar.I32), rhs: (string, TypeVar.I32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_plus_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s + %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
    def minus(lhs: (string, TypeVar.I32), rhs: (string, TypeVar.I32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_minus_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s - %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
    def equals(lhs: (string, TypeVar.I32), rhs: (string, TypeVar.I32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_equals_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s == %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
    def not_equals(lhs: (string, TypeVar.I32), rhs: (string, TypeVar.I32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_not_equals__%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s != %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
}
def rtcast_i32(x: i32) -> (string, TypeVar.I32) {
    def var_name = uidl("rtcast");
    code_builder.puts(Strings.format2("int %s = %d;\n", var_name, x));
    return (var_name, TypeVar.I32);
}
component EmitOpF32 {
    def plus(lhs: (string, TypeVar.F32), rhs: (string, TypeVar.F32)) -> (string, TypeVar.F32) {
        def new_var = uidl(Strings.format2("%s_plus_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("float %s = %s + %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.F32);
    }
    def minus(lhs: (string, TypeVar.F32), rhs: (string, TypeVar.F32)) -> (string, TypeVar.F32) {
        def new_var = uidl(Strings.format2("%s_minus_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("float %s = %s - %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.F32);
    }
    def equals(lhs: (string, TypeVar.F32), rhs: (string, TypeVar.F32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_minus_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s - %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
    def gt(lhs: (string, TypeVar.F32), rhs: (string, TypeVar.F32)) -> (string, TypeVar.I32) {
        def new_var = uidl(Strings.format2("%s_gt_%s", lhs.0, rhs.0));
        code_builder.puts(Strings.format3("int %s = %s > %s;\n", new_var, lhs.0, rhs.0));
        return (new_var, TypeVar.I32);
    }
}
def emitIf(v: (string, TypeVar.I32)) {
    code_builder.puts(Strings.format1("if (%s) {\n", v.0));
}
def emitIfStatic(v: bool) {
    code_builder.puts(Strings.format1("if (%z) {\n", v));
}
def emitElse() {
    code_builder.puts("} else {\n");
}
def emitEnd() {
    code_builder.puts("}\n");
}

def readImmULEB32() -> u32 {
    return codeptr.read_uleb32();
}

def readImmILEB32() -> i32 {
    return i32.!(codeptr.read_uleb32());
}

def readImmULEB64() -> u64 {
    return codeptr.read_uleb64();
}

def readImmILEB64() -> i64 {
    return i64.!(codeptr.read_uleb64());
}

def readImmU8() -> u8 {
    return codeptr.read1();
}

def readImmBlockType() -> () {
    def bt = codeptr.read_BlockTypeCode();
    return ();
}

def pop_i32() -> (string, TypeVar.I32) {
    def sp = stack.pop();
    def var_name = sp.0;
    def var_type = sp.1;
    match (var_type) {
        I32 => return (var_name, TypeVar.I32);
        _ => {
            assert(false);
            return (null, TypeVar.I32);
        }
    }
}
def pop_u32() -> (string, TypeVar.U32) {
    def sp = stack.pop();
    def var_name = sp.0;
    def var_type = sp.1;
    match (var_type) {
        U32 => return (var_name, TypeVar.U32);
        _ => {
            assert(false);
            return (null, TypeVar.U32);
        }
    }
}
def pop_i64() -> i64;
def pop_u64() -> (string, TypeVar.U64);
def pop_f32() -> (string, TypeVar.F32);
def pop_f64() -> double;
def pop_v128() -> v128;
def pop_Object() -> Object;
def pop_Value(tv: TypeVar) -> (string, TypeVar) {
    def sp = stack.pop();
    assert(tv == sp.1);
    return sp;
}

def push_i32(v: (string, TypeVar.I32)) {
    stack.push(v);
}
def push_u32(v: (string, TypeVar.U32)) {
    stack.push(v);
}
def push_i64(v: i64);
def push_u64(v: u64);
def push_f32(v: (string, TypeVar.F32));
def push_f64(v: double);
def push_v128(v: v128);
def push_Object(v: Object);
def push_Value(tv: TypeVar, v: (string, TypeVar)) {
    stack.push(v);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> (string, TypeVar) {
    return stack.elems[index];
}
def setLocal(tv: TypeVar, index: u32, v: (string, TypeVar)) {
    // TODO: assert that v has tv
    stack.elems[index] = v;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> (string, TypeVar);
def setGlobal(tv: TypeVar, index: u32, v: (string, TypeVar));

// Function context.
def f_getLabel(depth: u32) -> int {
    return int.!(depth);
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.!(index)];
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar;
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind;
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset;
def m_isMemory64(memory_index: u32) -> bool;
def m_isTable64(memory_index: u32) -> bool;
def m_getFuncSignature(func_index: u32) -> Signature;
def m_getSignature(sig_index: u32) -> Signature;

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Signature, func_index: (string, TypeVar.U64)) -> Function;
def i_getTableFunction32(table_index: u32, sig: Signature, func_index: (string, TypeVar.U32)) -> Function;
def i_getFunction(func_index: u32) -> Function;

// Control flow.
def doCall(sig: Signature, target: Function);

def doBranch(label: int) {
    def ctl_idx = ctl_stack.elems[ctl_stack.top - 1 - label];
    var label_name: string;
    match (ctls[ctl_idx]) {
        Block(_, ln) => label_name = ln;
        Loop(_, _, ln) => label_name = ln;
        _ => label_name = null;
    }
    code_builder.puts("goto ").puts(label_name).ln();
}

def doFallThru() {
}

// Machine intrinsics.
def mach_readStructField_i8(obj: Object, offset: FieldOffset) -> i8;
def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
def mach_readStructField_i16(obj: Object, offset: FieldOffset) -> i16;
def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32;
def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object;

def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) -> u32;

def mach_readTable64(table_index: u32, index: (string, TypeVar.U64)) -> Object;
def mach_readTable32(table_index: u32, index: (string, TypeVar.U32)) -> Object;

def mach_writeTable64(table_index: u32, index: (string, TypeVar.U64), val: Object);
def mach_writeTable32(table_index: u32, index: (string, TypeVar.U32), val: Object);

// Traps.
def invalid();
def trapNull();
def trapUnreachable();

def doBlock(bt: ()) {
    def label_name = uidl("block_end");
    if (ctls[codeptr.pos] == CompilerCtlEntry.None) ctls[codeptr.pos] = CompilerCtlEntry.Block(-1, label_name);
    ctl_stack.push(codeptr.pos);
}

def doLoop(bt: ()) {
    def label_name = uidl("loop_start");
    code_builder.puts(label_name).puts(":\n");
    if (ctls[codeptr.pos] == CompilerCtlEntry.None) ctls[codeptr.pos] = CompilerCtlEntry.Loop(codeptr.pos, -1, label_name);
    ctl_stack.push(codeptr.pos);
}

def doEnd() {
    def ctl_idx = ctl_stack.pop();
    match (ctls[ctl_idx]) {
        Block(end_pc, label_name) => {
            code_builder.puts(label_name).puts(":\n");
            if (end_pc == -1) ctls[ctl_idx] = CompilerCtlEntry.Block(codeptr.pos, label_name);
        }
        Loop(start_pc, end_pc, label_name) => {
            if (end_pc == -1) ctls[ctl_idx] = CompilerCtlEntry.Loop(start_pc, codeptr.pos, label_name);
        }
        None => doReturn();
    }
}

def doReturn() {
    return;
}

def doTry(bt: ()) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    System.puts("push\n");
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.I32;
        _ => tv = TypeVar.I32; // TODO
    }
    
    for (i < count) local_types.put(tv);
}

component Compiler {
    def init(code: Array<byte>, args: Array<TypeVar>, ret: Array<TypeVar>) {
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        ctls = Array.new(code.length);
        for (i < code.length) ctls[i] = CompilerCtlEntry.None;
        ctl_stack = ArrayStack.new();

        code_builder = StringBuilder.new();

        for (a in args) local_types.put(TypeVar.I32);
        for (i < args.length) {
            stack.push((Strings.format1("local_%d", i), TypeVar.I32));
        }
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        while (codeptr.pos < codeptr.data.length) {
            def op = codeptr.read_opcode();
            System.puts(op.mnemonic);
            System.ln();
            DISPATCH_TABLE[op.code]();
        }
    }

    def getCode() => code_builder.toString();
}
