component STFieldMgr {
    var fields: Vector<(string, string)> = Vector.new(); // (name, type)
    var entries: Vector<long> = Vector.new(); // keep track of which bitset insts are actually used

    def fieldIdx(field_name: string, field_tipe: string) -> int {
    	for (i < fields.length) if (Strings.equal(fields[i].0, field_name)) {
	    // TODO: check field_tipe eq
	    return i;
	}

	fields.put((field_name, field_tipe));
	return fields.length - 1;
    }

    def fieldToBitmask(field_name: string, field_tipe: string) -> long {
	def idx = byte.!(fieldIdx(field_name, field_tipe));
	return 1L << idx;
    }

    def fieldsToBitset(fields: Vector<(string, string)>) -> long {
	var set = 0L;
	for (i < fields.length) {
	    def mask = fieldToBitmask(fields[i]);
	    set |= mask;
	}

	return set;
    }

    def bitsetToFields(bs: long) -> Vector<(string, string)> {
        var result = Vector<(string, string)>.new();
        for (i < 64) {
            def mask = 1L << byte.!(i);
            if ((bs & mask) != 0L) {
                if (i < fields.length) {
                    result.put(fields[i]);
                }
            }
        }
        return result;
    }

    def putEntry(fields: Vector<(string, string)>) -> long {
	def bs = fieldsToBitset(fields);
	if (bs == 0) return 0;

        for (i < entries.length) if (entries[i] == bs) return bs;

	entries.put(bs);
	return bs;
    }

    def bitsetCaseName(bs: long) -> string {
	def builder = StringBuilder.new();
	def fields = bitsetToFields(bs);
	for (i < fields.length) {
	    def n = fields[i].0;
	    n[0] -= 32; // uppercase first letter
	    builder.puts(n);
	    n[0] += 32;
	}
	return builder.toString();
    }
}

def getSidetableFields(stmt: VirgilStmt, buf: Vector<(string, string)>) {
    match (stmt) {
        Expr(_) => return;
        Return(_) => return;
	Match(_, _) => return;
	Injected(_) => return;
        Block(ss) => for (s in ss) getSidetableFields(s, buf);
	If(_, t, e) => {
	    getSidetableFields(t, buf);
	    getSidetableFields(e, buf);
	}
        Local(name, _, sidetable, rtcast) => if (sidetable) buf.put((name, "int")); // TODO: tipe
    }
}

class CBDDef(field_bitset: long, opcode: string, body: VirgilStmt) {
    def buildString(buf: StringBuilder) {
        // TODO
    }
}

class SidetableEntry(fields: Array<(string, string)>) {
    def field_bitset() -> long {
	return 0; // TODO
    }
}

def is_newline(c: byte) -> bool {
    return c == '\n';
}

def find_idx(s: string, c: byte) -> int {
    for (i < s.length) if (s[i] == c) {
        return i;
    }

    return -1;
}

def extractInstrNames(v3_file: string) -> Array<string> {
    def defs = Vector<string>.new();

    // the .v3 file has the //@bytecode start comments, but we can only get
    // the s-expressions from the full file. To solve this, find the definition
    // names from the raw .v3 file, and then actually parse them from the s-expr file
    def lines = Strings.splitOnChar(v3_file, is_newline, -1);
    var cur_line = 0;
    while (!Strings.startsWith(lines[cur_line], "//@bytecode start")) cur_line += 1;

    while (!Strings.startsWith(lines[cur_line], "//@bytecode end")) {
        def line = Strings.strip(lines[cur_line]);
        if (GlobMatcher.new("def ?*()*{").matches(line)) {
            def fn_name_start = 4; // skip `def `
            def fn_name_end = find_idx(line, '(');

            def fn_name = Arrays.range(line, fn_name_start, fn_name_end);
            defs.put(fn_name);
            cur_line += 1;
        }
        
        cur_line += 1;
    }

    return defs.copy();
}

def isSpace(c: byte) -> bool {
    return c == ' ';
}

def hasMethod(reader: TextReader) -> bool {
    reader.skipWhitespace();
    return reader.optN("method") != -1;
}

def notLParen(c: byte) -> bool {
    return c != '(';
}

def readMethodName(reader: TextReader) -> string {
    reader.skipWhitespace();
    def end = reader.star_rel(1, notLParen);
    def tok = reader.readToken(end - reader.pos);
    return tok.image;
}

def nextLine(reader: TextReader) {
    def start_line = reader.line;
    while (reader.line == start_line) reader.advance1();
}

def containsStr(strs: Range<string>, k: string) -> bool {
    for (s in strs) if (Strings.equal(s, k)) return true;
    return false;
}

def instrumentSTLocals(stmt: VirgilStmt, bs: long) -> VirgilStmt {
    match (stmt) {
	Expr(_) => return stmt;
	Match(_, _) => return stmt;
	Injected(_) => return stmt;
        Block(ss) => return VirgilStmt.Block(Arrays.map(ss, instrumentSTLocals(_, bs)));
	If(c, t, e) => return VirgilStmt.If(c, instrumentSTLocals(t, bs), instrumentSTLocals(e, bs));
        Return(_) => {
	    // TODO: this should be independent of return, move it to extractDefs
	    if (bs == 0) return stmt;
	    // extract fields from st_builder into real st case
	    def name = STFieldMgr.bitsetCaseName(bs);
	    def fields = STFieldMgr.bitsetToFields(bs);
	    def injBuilder = StringBuilder.new();
	    injBuilder.puts("def st_case = STEntry.");
	    injBuilder.puts(name);
	    injBuilder.puts("(\n");
	    for (i < fields.length) {
		injBuilder.puts("      ");
	        injBuilder.puts(fields[i].0);
		if (i + 1 < fields.length) injBuilder.puts(",");
		injBuilder.puts("\n");
	    }
	    injBuilder.puts("  );\n");
	    injBuilder.puts("  st_entries.put(st_case);");
	    def inj = VirgilStmt.Injected(injBuilder.toString());
	    return inj.appendStmt(stmt).flatten();
	}
	Local(name, body, sidetable, rtcast) => {
	    if (Strings.equal(name, "test")) {
		// TODO: this is a hack
                return VirgilStmt.Injected("var test = TypeVar.I32;");
	    }
	    var new_body = body;
	    if (rtcast != null) {
	        new_body = VirgilExpr.AppExpr(rtcast, [body]);
	    }
	    var base = VirgilStmt.Local(name, new_body, sidetable, rtcast);
	    if (sidetable) {
		def inj_builder = StringBuilder.new();
		inj_builder.puts("st_builder.");
		inj_builder.puts(name);
		inj_builder.puts(" = ");
		inj_builder.puts(name);
		inj_builder.puts(";");
		def assignment = VirgilStmt.Injected(inj_builder.toString());
		return base.appendStmt(assignment).flatten();
	    } else {
	        return base;
	    }
	}
    }
}

def killConditionals(stmt: VirgilStmt) -> VirgilStmt {
    match (stmt) {
        Expr(_) => return stmt;
	Match(_, _) => return stmt;
	Injected(_) => return stmt;
        Return(_) => return stmt;
	Local(_, _, _, _) => return stmt;
        Block(ss) => return VirgilStmt.Block(Arrays.map(ss, killConditionals));
	If(c, t, e) => {
            var is_static = false;
	    match (c) {
                AppExpr(f, a) => is_static = Strings.startsWith(f, "m_") || Strings.startsWith(f, "f_");
		_ => {}
	    }
	    // remove test if it's not static, because then we run both branches
	    if (!is_static) {
		if (e.isEmptyBlock()) return t;
		else return t.appendStmt(e);
            } else {
                return stmt;
            }
	}
    }
}

def extractDefs(instrs: Array<string>, filename: string, file_content: string) -> Array<CBDDef> {
    def defs: Vector<CBDDef> = Vector.new();
    def sexp_parser = SExprParser.new(filename, file_content);
    while (sexp_parser.ok && sexp_parser.pos < sexp_parser.data.length) {
        if (hasMethod(sexp_parser)) {
            def meth = readMethodName(sexp_parser);
            if (!containsStr(instrs, meth)) continue;
            nextLine(sexp_parser);
            def result = sexp_parser.readSExpr();
            match (result) {
                Success(sexp) => {
                    def stmt_res = VirgilStmts.from_sexpr(sexp);
                    match (stmt_res) {
                        Success(stmt) => {
			    def st_field_buf = Vector<(string, string)>.new();
			    getSidetableFields(stmt, st_field_buf);

			    def bs = STFieldMgr.putEntry(st_field_buf);
			    var substStmt = stmt.substTy("i32", "TypeVar.I32");
			    def st_fields = STFieldMgr.bitsetToFields(bs);
 			    def instStmt = killConditionals(instrumentSTLocals(substStmt, bs)).flatten();
			    defs.put(CBDDef.new(bs, meth, instStmt));
                        }
                        _ => {
                            System.write(2, meth);
                            System.write(2, ": skipping unhandled stmt sexpr\n");
                            nextLine(sexp_parser);
                        }
                    }
                }
                _ => {
                    break; // TODO
                }
            }
        } else {
            nextLine(sexp_parser);
        }
    }

    return defs.copy();
}

def main(args: Array<string>) {
    def v3file = args[0];
    def v3bytes = System.fileLoad(v3file);
    if (v3bytes == null) {
        System.puts("Error reading ");
        System.puts(v3file);
        System.ln();
    }

    def sexpr_file = args[1];
    def sexpr_bytes = System.fileLoad(sexpr_file);
    if (sexpr_bytes == null) {
        System.puts("Error reading ");
        System.puts(sexpr_file);
        System.ln();
    }

    def instrs = extractInstrNames(v3bytes);
    def defs = extractDefs(instrs, sexpr_file, sexpr_bytes);

    // for concrete interpreter 

    def codestr_builder = StringBuilder.new();

    def dispatch_builder = StringBuilder.new();
    dispatch_builder.puts("def build_dispatch_table() -> Array<void -> void> {\n");
    dispatch_builder.puts("  DISPATCH_TABLE = Array.new(0xE5 + 1);\n"); // 0xE5 = highest opcode (SWITCH)

    for (d in defs) {
	codestr_builder.puts("// st bitset: ");
	codestr_builder.putd(d.field_bitset);
	codestr_builder.ln();
        codestr_builder.puts("def ");
        codestr_builder.puts(d.opcode);
        codestr_builder.puts("() ");
        codestr_builder.puts(d.body.toString());
        codestr_builder.ln();

        dispatch_builder.puts("  DISPATCH_TABLE[Opcode.");
        dispatch_builder.puts(d.opcode);
        dispatch_builder.puts(".code] = ");
        dispatch_builder.puts(d.opcode);
        dispatch_builder.puts(";\n");
    }

    dispatch_builder.puts("  return DISPATCH_TABLE;\n");
    dispatch_builder.puts("}\n");

    // TODO:
    // instead of a global st builder, gen each case, change the local
    // instrumentation to init a single case and then put it into sidetable meta list,
    // here generate the sidetable meta list and adt
    def st_builder_builder = StringBuilder.new();
    st_builder_builder.puts("class STBuilder {\n");
    for (i < STFieldMgr.fields.length) {
        def field = STFieldMgr.fields[i].0;
        def tp = STFieldMgr.fields[i].1;
	st_builder_builder.puts("    var ");
	st_builder_builder.puts(field);
	st_builder_builder.puts(": ");
	st_builder_builder.puts(tp);
	st_builder_builder.puts(";\n");
    }
    st_builder_builder.puts("}\n");
    st_builder_builder.puts("type STEntry {\n");
    // TODO
    for (i < STFieldMgr.entries.length) {
        def entry_bs = STFieldMgr.entries[i];
	def entry_fields = STFieldMgr.bitsetToFields(entry_bs);
	def entry_name = STFieldMgr.bitsetCaseName(entry_bs);
	st_builder_builder.puts("    case ");
	st_builder_builder.puts(entry_name);
	st_builder_builder.puts("(\n");
	// TODO
	for (i < entry_fields.length) {
	    st_builder_builder.puts("        ");
	    st_builder_builder.puts(entry_fields[i].0);
	    st_builder_builder.puts(": ");
	    st_builder_builder.puts(entry_fields[i].1);
	    if (i + 1 < entry_fields.length) st_builder_builder.puts(",");
	    st_builder_builder.puts("\n");
        }
	st_builder_builder.puts("    );\n");
    }
    st_builder_builder.puts("}\n");

    def concrete_template = args[2];
    def concrete_bytes = System.fileLoad(concrete_template);
    if (concrete_bytes == null) {
        System.puts("Error reading ");
        System.puts(concrete_template);
        System.ln();
    }

    var first_newline = 0;
    while (first_newline < concrete_bytes.length) {
        if (concrete_bytes[first_newline] == '\n') break;
        first_newline += 1;
    }
    def template_code = Arrays.range(concrete_bytes, first_newline + 1, concrete_bytes.length);

    def final_code_builder = StringBuilder.new();
    final_code_builder.puts("// GENERATED BY ValidatorGen.v3\n");
    final_code_builder.puts(codestr_builder.toString());
    final_code_builder.puts(dispatch_builder.toString());
    final_code_builder.puts(st_builder_builder.toString());
    final_code_builder.puts(template_code);

    System.puts(final_code_builder.toString());
}
