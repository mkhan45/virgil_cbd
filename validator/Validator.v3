// GENERATED BY ValidatorGen.v3
// st bitset: 0
def UNREACHABLE() {
	// eff01 -- static: no, type: ⊥, effect: none

	def eff01 = trapUnreachable();
}
// st bitset: 0
def LOCAL_GET() {
	// val13 -- static: no, type: ⊥, effect: none
// index8 -- static: yes, type: u32, effect: none
// eff216 -- static: no, type: ⊥, effect: push
// arg414 -- static: no, type: ⊥, effect: none
// arg315 -- static: yes, type: ⊥, effect: none
// arg611 -- static: yes, type: u32, effect: none
// arg512 -- static: yes, type: ⊥, effect: none
// tv10 -- static: yes, type: ⊥, effect: none
// arg79 -- static: yes, type: u32, effect: none

	def index8 = readImmULEB32();
	def arg79 = (index8);
	def tv10 = f_getLocalType(arg79);
	def arg611 = (index8);
	def arg512 = (tv10);
	def val13 = getLocal(arg512, arg611);
	def arg414 = (val13);
	def arg315 = (tv10);
	def eff216 = push_Value(arg315, arg414);
}
// st bitset: 0
def LOCAL_SET() {
	// arg1929 -- static: yes, type: u32, effect: none
// index23 -- static: yes, type: u32, effect: none
// tv25 -- static: yes, type: ⊥, effect: none
// arg2028 -- static: no, type: ⊥, effect: none
// arg1830 -- static: yes, type: ⊥, effect: none
// arg2126 -- static: yes, type: ⊥, effect: none
// eff1731 -- static: no, type: ⊥, effect: none
// arg2224 -- static: yes, type: u32, effect: none
// val27 -- static: no, type: ⊥, effect: pop

	def index23 = readImmULEB32();
	def arg2224 = (index23);
	def tv25 = f_getLocalType(arg2224);
	def arg2126 = (tv25);
	def val27 = pop_Value(arg2126);
	def arg2028 = (val27);
	def arg1929 = (index23);
	def arg1830 = (tv25);
	def eff1731 = setLocal(arg1830, arg1929, arg2028);
}
// st bitset: 0
def LOCAL_TEE() {
	// val45 -- static: no, type: ⊥, effect: pop
// arg3450 -- static: no, type: ⊥, effect: none
// arg3351 -- static: yes, type: ⊥, effect: none
// eff3252 -- static: no, type: ⊥, effect: push
// arg4042 -- static: yes, type: u32, effect: none
// index41 -- static: yes, type: u32, effect: none
// arg3846 -- static: no, type: ⊥, effect: none
// arg3747 -- static: yes, type: u32, effect: none
// arg3648 -- static: yes, type: ⊥, effect: none
// tv43 -- static: yes, type: ⊥, effect: none
// arg3944 -- static: yes, type: ⊥, effect: none
// eff3549 -- static: no, type: ⊥, effect: none

	def index41 = readImmULEB32();
	def arg4042 = (index41);
	def tv43 = f_getLocalType(arg4042);
	def arg3944 = (tv43);
	def val45 = pop_Value(arg3944);
	def arg3846 = (val45);
	def arg3747 = (index41);
	def arg3648 = (tv43);
	def eff3549 = setLocal(arg3648, arg3747, arg3846);
	def arg3450 = (val45);
	def arg3351 = (tv43);
	def eff3252 = push_Value(arg3351, arg3450);
}
// st bitset: 0
def GLOBAL_GET() {
	// index59 -- static: yes, type: u32, effect: none
// arg5565 -- static: no, type: ⊥, effect: none
// arg5466 -- static: yes, type: ⊥, effect: none
// arg5762 -- static: yes, type: u32, effect: none
// arg5663 -- static: yes, type: ⊥, effect: none
// eff5367 -- static: no, type: ⊥, effect: push
// arg5860 -- static: yes, type: u32, effect: none
// val64 -- static: no, type: ⊥, effect: none
// tv61 -- static: yes, type: ⊥, effect: none

	def index59 = readImmULEB32();
	def arg5860 = (index59);
	def tv61 = m_getGlobalType(arg5860);
	def arg5762 = (index59);
	def arg5663 = (tv61);
	def val64 = getGlobal(arg5663, arg5762);
	def arg5565 = (val64);
	def arg5466 = (tv61);
	def eff5367 = push_Value(arg5466, arg5565);
}
// st bitset: 0
def GLOBAL_SET() {
	// val78 -- static: no, type: ⊥, effect: pop
// arg7179 -- static: no, type: ⊥, effect: none
// arg6981 -- static: yes, type: ⊥, effect: none
// arg7277 -- static: yes, type: ⊥, effect: none
// eff6882 -- static: no, type: ⊥, effect: none
// arg7375 -- static: yes, type: u32, effect: none
// index74 -- static: yes, type: u32, effect: none
// tv76 -- static: yes, type: ⊥, effect: none
// arg7080 -- static: yes, type: u32, effect: none

	def index74 = readImmULEB32();
	def arg7375 = (index74);
	def tv76 = m_getGlobalType(arg7375);
	def arg7277 = (tv76);
	def val78 = pop_Value(arg7277);
	def arg7179 = (val78);
	def arg7080 = (index74);
	def arg6981 = (tv76);
	def eff6882 = setGlobal(arg6981, arg7080, arg7179);
}
// st bitset: 0
def TABLE_GET() {
	// table_index93 -- static: yes, type: u32, effect: none
// arg91103 -- static: no, type: ⊥, effect: none
// arg8797 -- static: no, type: ⊥, effect: none
// arg8698 -- static: yes, type: u32, effect: none
// val99 -- static: no, type: ⊥, effect: none
// val105 -- static: no, type: ⊥, effect: none
// eff88107 -- static: no, type: ⊥, effect: push
// eff84101 -- static: no, type: ⊥, effect: push
// index102 -- static: no, type: ⊥, effect: pop
// index96 -- static: no, type: ⊥, effect: pop
// arg89106 -- static: no, type: ⊥, effect: none
// arg85100 -- static: no, type: ⊥, effect: none
// arg9294 -- static: yes, type: u32, effect: none
// cond8395 -- static: yes, type: ⊥, effect: none
// arg90104 -- static: yes, type: u32, effect: none

	def table_index93 = readImmULEB32();
	def arg9294 = (table_index93);
	def cond8395 = m_isTable64(arg9294);
	if (cond8395) {
		def index96 = pop_u64();
		def arg8797 = (index96);
		def arg8698 = (table_index93);
		def val99 = mach_readTable64(arg8698, arg8797);
		def arg85100 = (val99);
		def eff84101 = push_Object(arg85100);
	} else {
		def index102 = pop_u32();
		def arg91103 = (index102);
		def arg90104 = (table_index93);
		def val105 = mach_readTable32(arg90104, arg91103);
		def arg89106 = (val105);
		def eff88107 = push_Object(arg89106);
	}
}
// st bitset: 0
def TABLE_SET() {
	// arg117119 -- static: yes, type: u32, effect: none
// arg111124 -- static: no, type: ⊥, effect: none
// arg116129 -- static: no, type: ⊥, effect: none
// arg112123 -- static: no, type: ⊥, effect: none
// index128 -- static: no, type: ⊥, effect: pop
// val127 -- static: no, type: ⊥, effect: pop
// eff113132 -- static: no, type: ⊥, effect: none
// arg114131 -- static: yes, type: u32, effect: none
// index122 -- static: no, type: ⊥, effect: pop
// eff109126 -- static: no, type: ⊥, effect: none
// arg115130 -- static: no, type: ⊥, effect: none
// table_index118 -- static: yes, type: u32, effect: none
// val121 -- static: no, type: ⊥, effect: pop
// cond108120 -- static: yes, type: ⊥, effect: none
// arg110125 -- static: yes, type: u32, effect: none

	def table_index118 = readImmULEB32();
	def arg117119 = (table_index118);
	def cond108120 = m_isTable64(arg117119);
	if (cond108120) {
		def val121 = pop_Object();
		def index122 = pop_u64();
		def arg112123 = (val121);
		def arg111124 = (index122);
		def arg110125 = (table_index118);
		def eff109126 = mach_writeTable64(arg110125, arg111124, arg112123);
	} else {
		def val127 = pop_Object();
		def index128 = pop_u32();
		def arg116129 = (val127);
		def arg115130 = (index128);
		def arg114131 = (table_index118);
		def eff113132 = mach_writeTable32(arg114131, arg115130, arg116129);
	}
}
// st bitset: 0
def CALL() {
	// arg137139 -- static: yes, type: u32, effect: none
// eff133145 -- static: no, type: ⊥, effect: none
// index138 -- static: yes, type: u32, effect: none
// arg134144 -- static: yes, type: ⊥, effect: none
// arg135143 -- static: no, type: ⊥, effect: none
// arg136141 -- static: yes, type: u32, effect: none
// target142 -- static: no, type: ⊥, effect: none
// sig140 -- static: yes, type: ⊥, effect: none

	def index138 = readImmULEB32();
	def arg137139 = (index138);
	def sig140 = m_getFuncSignature(arg137139);
	def arg136141 = (index138);
	def target142 = i_getFunction(arg136141);
	def arg135143 = (target142);
	def arg134144 = (sig140);
	def eff133145 = doCall(arg134144, arg135143);
}
// st bitset: 1
def CALL_INDIRECT() {
	// func_index167 -- static: no, type: ⊥, effect: pop
// arg156178 -- static: yes, type: u32, effect: none
// arg150170 -- static: yes, type: u32, effect: none
// func_index175 -- static: no, type: ⊥, effect: pop
// arg157177 -- static: yes, type: ⊥, effect: none
// table_index162 -- static: yes, type: u32, effect: none
// cond146166 -- static: yes, type: ⊥, effect: none
// arg158176 -- static: no, type: ⊥, effect: none
// target179 -- static: no, type: ⊥, effect: none
// arg159165 -- static: yes, type: u32, effect: none
// arg154181 -- static: yes, type: ⊥, effect: none
// arg148173 -- static: yes, type: ⊥, effect: none
// arg155180 -- static: no, type: ⊥, effect: none
// sig_index161 -- static: yes, type: u32, effect: none
// sig164 -- static: yes, type: ⊥, effect: none
// arg151169 -- static: yes, type: ⊥, effect: none
// ret153182 -- static: no, type: ⊥, effect: none
// arg149172 -- static: no, type: ⊥, effect: none
// arg152168 -- static: no, type: ⊥, effect: none
// ret147174 -- static: no, type: ⊥, effect: none
// target171 -- static: no, type: ⊥, effect: none
// arg160163 -- static: yes, type: u32, effect: none

	def sig_index161 = readImmULEB32();
	def table_index162 = readImmULEB32();
	def arg160163 = (sig_index161);
	def sig164 = m_getSignature(arg160163);
	def arg159165 = (table_index162);
	def cond146166 = m_isTable64(arg159165);
	if (cond146166) {
		def func_index167 = pop_u64();
		def arg152168 = (func_index167);
		def arg151169 = (sig164);
		def arg150170 = (table_index162);
		def target171 = i_getTableFunction64(arg150170, arg151169, arg152168);
		def arg149172 = (target171);
		def arg148173 = (sig164);
		def ret147174 = doCall(arg148173, arg149172);
		return ret147174;
	} else {
		def func_index175 = pop_u32();
		def arg158176 = (func_index175);
		def arg157177 = (sig164);
		def arg156178 = (table_index162);
		def target179 = i_getTableFunction32(arg156178, arg157177, arg158176);
		def arg155180 = (target179);
		def arg154181 = (sig164);
		def ret153182 = doCall(arg154181, arg155180);
		return ret153182;
	}
}
// st bitset: 0
def I32_CONST() {
	// arg184186 -- static: yes, type: i32, effect: none
// x185 -- static: yes, type: i32, effect: none
// eff183187 -- static: no, type: ⊥, effect: push

	def x185 = readImmILEB32();
	def arg184186 = (x185);
	def eff183187 = push_i32(arg184186);
}
// st bitset: 0
def I32_ADD() {
	// eff188198 -- static: no, type: ⊥, effect: push
// arg189197 -- static: no, type: ⊥, effect: none
// x192 -- static: no, type: i32, effect: pop
// y193 -- static: no, type: i32, effect: pop
// left190194 -- static: no, type: i32, effect: none
// right191195 -- static: no, type: i32, effect: none
// r196 -- static: no, type: ⊥, effect: none

	def x192 = pop_i32();
	def y193 = pop_i32();
	def left190194 = (x192);
	def right191195 = (y193);
	def r196 = TypeVar.I32.plus(left190194, right191195);
	def arg189197 = (r196);
	def eff188198 = push_i32(arg189197);
}
// st bitset: 0
def I32_SUB() {
	// r207 -- static: no, type: ⊥, effect: none
// eff199209 -- static: no, type: ⊥, effect: push
// arg200208 -- static: no, type: ⊥, effect: none
// arg201206 -- static: no, type: i32, effect: none
// x203 -- static: no, type: i32, effect: pop
// y204 -- static: no, type: i32, effect: pop
// arg202205 -- static: no, type: i32, effect: none

	def x203 = pop_i32();
	def y204 = pop_i32();
	def arg202205 = (x203);
	def arg201206 = (y204);
	def r207 = i32.-(arg201206, arg202205);
	def arg200208 = (r207);
	def eff199209 = push_i32(arg200208);
}
// st bitset: 0
def I32_EQZ() {
	// eff211222 -- static: no, type: ⊥, effect: push
// eff213224 -- static: no, type: ⊥, effect: push
// cond210220 -- static: no, type: ⊥, effect: none
// arg212221 -- static: yes, type: i32, effect: none
// arg214223 -- static: yes, type: i32, effect: none
// x217 -- static: no, type: i32, effect: pop
// left215218 -- static: no, type: i32, effect: none
// right216219 -- static: yes, type: i32, effect: none

	def x217 = pop_i32();
	def left215218 = (x217);
	def right216219 : int = 0;
	def rtcast225 = rtcast_i32(right216219);
	def cond210220 = TypeVar.I32.equals(left215218, rtcast225);
	if (cond210220) {
		def arg212221 : int = 1;
		def eff211222 = push_i32(arg212221);
	} else {
		def arg214223 : int = 0;
		def eff213224 = push_i32(arg214223);
	}
}
// st bitset: 0
def F32_MAX() {
	// cond231245 -- static: no, type: ⊥, effect: none
// arg227249 -- static: no, type: f32, effect: none
// left229246 -- static: no, type: f32, effect: none
// left235240 -- static: no, type: f32, effect: none
// right236241 -- static: no, type: f32, effect: none
// a238 -- static: no, type: f32, effect: pop
// r239 -- static: no, type: f32, effect: none
// cond228248 -- static: no, type: ⊥, effect: none
// cond234242 -- static: no, type: ⊥, effect: none
// b237 -- static: no, type: f32, effect: pop
// right230247 -- static: no, type: f32, effect: none
// eff226250 -- static: no, type: ⊥, effect: push
// left232243 -- static: no, type: f32, effect: none
// right233244 -- static: no, type: f32, effect: none

	def b237 = pop_f32();
	def a238 = pop_f32();
	def r239 = (a238);
	def left235240 = (a238);
	def right236241 = (b237);
	def cond234242 = TypeVar.F32.gt(left235240, right236241);
	def left232243 = (a238);
	def right233244 = (b237);
	def cond231245 = TypeVar.F32.equals(left232243, right233244);
	def left229246 = (b237);
	def right230247 = (a238);
	def cond228248 = TypeVar.F32.gt(left229246, right230247);
	def arg227249 = (r239);
	def eff226250 = push_f32(arg227249);
}
// st bitset: 2
def BR() {
	// arg254256 -- static: yes, type: u32, effect: none
// label257 -- static: yes, type: ⊥, effect: none
// depth255 -- static: yes, type: u32, effect: none
// ret251260 -- static: no, type: i32, effect: none
// eff252259 -- static: no, type: ⊥, effect: ctl
// arg253258 -- static: yes, type: ⊥, effect: none

	def depth255 = readImmULEB32();
	def arg254256 = (depth255);
	def label257 = f_getLabel(arg254256);
	def arg253258 = (label257);
	def eff252259 = doBranch(arg253258);
	def ret251260 = (void);
	return ret251260;
}
// st bitset: 2
def BR_IF() {
	// eff263277 -- static: no, type: ⊥, effect: ctl
// ret261279 -- static: no, type: i32, effect: none
// cond262275 -- static: no, type: ⊥, effect: none
// arg264276 -- static: yes, type: ⊥, effect: none
// eff265278 -- static: no, type: ⊥, effect: none
// left266273 -- static: no, type: i32, effect: none
// right267274 -- static: yes, type: i32, effect: none
// depth269 -- static: yes, type: u32, effect: none
// arg268270 -- static: yes, type: u32, effect: none
// cond272 -- static: no, type: i32, effect: pop
// label271 -- static: yes, type: ⊥, effect: none

	def depth269 = readImmULEB32();
	def arg268270 = (depth269);
	def label271 = f_getLabel(arg268270);
	def cond272 = pop_i32();
	def left266273 = (cond272);
	def right267274 : int = 0;
	def rtcast280 = rtcast_i32(right267274);
	def cond262275 = TypeVar.I32.not_equals(left266273, rtcast280);
	def arg264276 = (label271);
	def eff263277 = doBranch(arg264276);
	def eff265278 = doFallThru();
	def ret261279 = (void);
	return ret261279;
}
// st bitset: 0
def BLOCK() {
	// arg282284 -- static: yes, type: ⊥, effect: none
// bt283 -- static: yes, type: ⊥, effect: none
// eff281285 -- static: no, type: ⊥, effect: none

	def bt283 = readImmBlockType();
	def arg282284 = (bt283);
	def eff281285 = doBlock(arg282284);
}
// st bitset: 0
def LOOP() {
	// arg287289 -- static: yes, type: ⊥, effect: none
// bt288 -- static: yes, type: ⊥, effect: none
// eff286290 -- static: no, type: ⊥, effect: none

	def bt288 = readImmBlockType();
	def arg287289 = (bt288);
	def eff286290 = doLoop(arg287289);
}
// st bitset: 0
def TRY() {
	// arg292294 -- static: yes, type: ⊥, effect: none
// bt293 -- static: yes, type: ⊥, effect: none
// eff291295 -- static: no, type: ⊥, effect: none

	def bt293 = readImmBlockType();
	def arg292294 = (bt293);
	def eff291295 = doTry(arg292294);
}
// st bitset: 0
def IF() {
	// bt303 -- static: yes, type: ⊥, effect: none
// eff297311 -- static: no, type: ⊥, effect: ctl
// cond304 -- static: no, type: i32, effect: pop
// arg298310 -- static: yes, type: ⊥, effect: none
// eff299312 -- static: no, type: ⊥, effect: none
// label306 -- static: yes, type: ⊥, effect: none
// cond296309 -- static: no, type: ⊥, effect: none
// left300307 -- static: no, type: i32, effect: none
// right301308 -- static: yes, type: i32, effect: none
// arg302305 -- static: yes, type: ⊥, effect: none

	def bt303 = readImmBlockType();
	def cond304 = pop_i32();
	def arg302305 : u32 = 0;
	def label306 = f_getLabel(arg302305);
	def left300307 = (cond304);
	def right301308 : int = 0;
	def rtcast313 = rtcast_i32(right301308);
	def cond296309 = TypeVar.I32.equals(left300307, rtcast313);
	def arg298310 = (label306);
	def eff297311 = doBranch(arg298310);
	def eff299312 = doFallThru();
}
// st bitset: 0
def ELSE() {
	// arg316317 -- static: yes, type: ⊥, effect: none
// label318 -- static: yes, type: ⊥, effect: none
// eff314320 -- static: no, type: ⊥, effect: ctl
// arg315319 -- static: yes, type: ⊥, effect: none

	def arg316317 : u32 = 0;
	def label318 = f_getLabel(arg316317);
	def arg315319 = (label318);
	def eff314320 = doBranch(arg315319);
}
// st bitset: 0
def END() {
	// eff323324 -- static: no, type: ⊥, effect: none
// cond321325 -- static: yes, type: ⊥, effect: none
// eff322326 -- static: no, type: ⊥, effect: none

	def eff323324 = doEnd();
	def cond321325 = f_isAtEnd();
	if (cond321325) {
		def eff322326 = doReturn();
	} else {
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  DISPATCH_TABLE[Opcode.UNREACHABLE.code] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.LOCAL_GET.code] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.code] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.code] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.code] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.code] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.code] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.code] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.code] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.code] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.I32_CONST.code] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.code] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.code] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_EQZ.code] = I32_EQZ;
  DISPATCH_TABLE[Opcode.F32_MAX.code] = F32_MAX;
  DISPATCH_TABLE[Opcode.BR.code] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.code] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.code] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.code] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.code] = TRY;
  DISPATCH_TABLE[Opcode.IF.code] = IF;
  DISPATCH_TABLE[Opcode.ELSE.code] = ELSE;
  DISPATCH_TABLE[Opcode.END.code] = END;
  return DISPATCH_TABLE;
}
class STBuilder {
    var target: int;
    var label: int;
}
type STEntry {
    case Target(
        target: int
    );
    case Label(
        label: int
    );
}

var codeptr: CodePtr;
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>;
var stack: ArrayStack<TypeVar>;

// this is mainly to lift sidetable vars out of conditionals,
// probably a lot of ways to dodge that
var st_builder: STBuilder = STBuilder.new();
var st_entries: Vector<STEntry> = Vector.new();
var st_controls: Vector<int> = Vector.new(); // ctl idx of target

def assert(b: bool) {
    if (!b) {
        System.puts("assert fail :(\n");
	return [][1];
    }
}

type CtlEntry {
	case Block(end_pc: int, cont_stp: int);
	case Loop(start_pc: int, end_pc: int, cont_stp: int);
        case None;
}
var ctls: Array<CtlEntry>;
var ctl_stack: ArrayStack<int>;

// Constants
def HAS_MEM_INDEX = 0x40u8;

// Types.
type v128(low: u64, high: u64);
type Label(depth: u32);
// class Object { }
type TypeVar {
    case I32 {
        def plus(lhs: TypeVar.I32, rhs: TypeVar.I32) -> TypeVar.I32 { return TypeVar.I32; }
        def minus(lhs: TypeVar.I32, rhs: TypeVar.I32) -> TypeVar.I32 { return TypeVar.I32; }
    }
    case U32;
    case U64;
    case F32 {
    }
    case Err;
}
def rtcast_i32(x: i32) -> TypeVar.I32 {
    return TypeVar.I32;
}
type FieldOffset;
class Signature { }
// class Function { }

enum FieldKind {
	U8, U16, I32, I64, F32, F64, V128, REF
}

def readImmULEB32() -> u32 {
    return codeptr.read_uleb32();
}

def readImmILEB32() -> i32 {
    return i32.!(codeptr.read_uleb32());
}

def readImmULEB64() -> u64 {
    return codeptr.read_uleb64();
}

def readImmILEB64() -> i64 {
    return i64.!(codeptr.read_uleb64());
}

def readImmU8() -> u8 {
    return codeptr.read1();
}

def readImmBlockType() -> () {
    def bt = codeptr.read_BlockTypeCode();
    return ();
}

def pop_i32() -> TypeVar.I32 {
    match (stack.pop()) {
        I32 => return TypeVar.I32;
        _ => {
	    assert(false);
	    return TypeVar.I32;
	}
    }
}
def pop_u32() -> TypeVar.U32 {
    match (stack.pop()) {
        U32 => return TypeVar.U32;
        _ => {
	    assert(false);
	    return TypeVar.U32;
	}
    }
}
def pop_i64() -> i64;
def pop_u64() -> TypeVar.U64;
def pop_f32() -> float;
def pop_f64() -> double;
def pop_v128() -> v128;
def pop_Object() -> Object;
def pop_Value(tv: TypeVar) -> TypeVar {
    assert(tv == stack.pop());
    return tv;
}

def push_i32(v: TypeVar.I32) {
    stack.push(v);
}
def push_u32(v: u32) {
    stack.push(TypeVar.U32);
}
def trueVal() -> TypeVar.I32 {
    return TypeVar.I32;
}
def falseVal() -> TypeVar.I32 {
    return TypeVar.I32;
}
def i32_eqz(x: TypeVar.I32) -> TypeVar.I32 {
    return TypeVar.I32;
}
def push_i64(v: i64);
def push_u64(v: u64);
def push_f32(v: float);
def push_f64(v: double);
def push_v128(v: v128);
def push_Object(v: Object);
def push_Value(tv: TypeVar, v: TypeVar) {
    // TODO: assert v has tv
    stack.push(tv);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> TypeVar {
    return stack.elems[index];
}
def setLocal(tv: TypeVar, index: u32, v: TypeVar) {
    // TODO: assert that v has tv
    stack.elems[index] = tv;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> TypeVar;
def setGlobal(tv: TypeVar, index: u32, v: TypeVar);

// Function context.
def f_getLabel(depth: u32) -> int {
    return int.!(depth);
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.!(index)];
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar;
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind;
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset;
def m_isMemory64(memory_index: u32) -> bool;
def m_isTable64(memory_index: u32) -> bool;
def m_getFuncSignature(func_index: u32) -> Signature;
def m_getSignature(sig_index: u32) -> Signature;

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Signature, func_index: TypeVar.U64) -> Function;
def i_getTableFunction32(table_index: u32, sig: Signature, func_index: TypeVar.U32) -> Function;
def i_getFunction(func_index: u32) -> Function;

// Control flow.
def doCall(sig: Signature, target: Function);

def doBranch(label: int) {
    def ctl_idx = ctl_stack.elems[ctl_stack.top - 1 - label];
    st_controls.put(ctl_idx);
}

def doFallThru() {
}

// Machine intrinsics.
def mach_readStructField_i8(obj: Object, offset: FieldOffset) -> i8;
def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
def mach_readStructField_i16(obj: Object, offset: FieldOffset) -> i16;
def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32;
def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object;

def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) -> u32;

def mach_readTable64(table_index: u32, index: TypeVar.U64) -> Object;
def mach_readTable32(table_index: u32, index: TypeVar.U32) -> Object;

def mach_writeTable64(table_index: u32, index: TypeVar.U64, val: Object);
def mach_writeTable32(table_index: u32, index: TypeVar.U32, val: Object);

// Traps.
def invalid();
def trapNull();
def trapUnreachable();

def doBlock(bt: ()) {
    if (ctls[codeptr.pos] == CtlEntry.None) ctls[codeptr.pos] = CtlEntry.Block(-1, -1);
    ctl_stack.push(codeptr.pos);
}

def doLoop(bt: ()) {
    if (ctls[codeptr.pos] == CtlEntry.None) ctls[codeptr.pos] = CtlEntry.Loop(codeptr.pos, -1, st_entries.length);
    ctl_stack.push(codeptr.pos);
}

def doEnd() {
    def ctl_idx = ctl_stack.pop();
    match (ctls[ctl_idx]) {
        Block(end_pc, cont_stp) =>
	    if (end_pc == -1) ctls[ctl_idx] = CtlEntry.Block(codeptr.pos, st_entries.length - 1);
        Loop(start_pc, end_pc, cont_stp) => 
	    if (end_pc == -1) ctls[ctl_idx] = CtlEntry.Loop(start_pc, codeptr.pos, cont_stp);
        None => doReturn();
    }
}

def doReturn() {
    return;
}

def doTry(bt: ()) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    System.puts("push\n");
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.I32;
        _ => tv = TypeVar.I32; // TODO
    }
    
    for (i < count) local_types.put(tv);
}

component Validator {
    def init(code: Array<byte>, args: Array<TypeVar>, ret: Array<TypeVar>) {
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        ctls = Array.new(code.length);
        for (i < code.length) ctls[i] = CtlEntry.None;
        ctl_stack = ArrayStack.new();

        for (a in args) local_types.put(TypeVar.I32);
        for (a in args) stack.push(a);
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        while (codeptr.pos < codeptr.data.length) {
            def op = codeptr.read_opcode();
            System.puts(op.mnemonic);
            System.ln();
            DISPATCH_TABLE[op.code]();
        }
    }

    // for other sidetable entries, do we need a post processing phase?
    def build_sidetable() -> (Vector<STEntry>, Vector<(int, int)>) {
        def reified_st_controls = Vector<(int, int)>.new();
	for (i < st_controls.length) {
            def target_ctl = ctls[st_controls[i]];
	    var target_stp = -1;
	    var target_pc = -1;
	    match (target_ctl) {
		Block(epc, cstp) => {
		    target_pc = epc;
		    target_stp = cstp;
		}
		Loop(spc, epc, cstp) => {
		    target_pc = spc;
		    target_stp = cstp;
		}
		None => invalid();
	    }
	    reified_st_controls.put(target_pc, target_stp);
        }
        return (st_entries, reified_st_controls);
    }
}
