// GENERATED BY InterpreterGen.v3
def UNREACHABLE() {
	def eff00 = trapUnreachable();
}
def LOCAL_GET() {
	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val5 = getLocal(tv2, index0);
	def eff18 = push_Value(tv2, val5);
}
def LOCAL_SET() {
	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val4 = pop_Value(tv2);
	def eff98 = setLocal(tv2, index0, val4);
}
def LOCAL_TEE() {
	def index0 = readImmULEB32();
	def tv2 = f_getLocalType(index0);
	def val4 = pop_Value(tv2);
	def eff128 = setLocal(tv2, index0, val4);
	def eff911 = push_Value(tv2, val4);
}
def GLOBAL_GET() {
	def index0 = readImmULEB32();
	def tv2 = m_getGlobalType(index0);
	def val5 = getGlobal(tv2, index0);
	def eff128 = push_Value(tv2, val5);
}
def GLOBAL_SET() {
	def index0 = readImmULEB32();
	def tv2 = m_getGlobalType(index0);
	def val4 = pop_Value(tv2);
	def eff98 = setGlobal(tv2, index0, val4);
}
def TABLE_GET() {
	def table_index0 = readImmULEB32();
	def cond92 = m_isTable64(table_index0);
	if (cond92) {
		def index3 = pop_u64();
		def val6 = mach_readTable64(table_index0, index3);
		def eff108 = push_Object(val6);
	} else {
		def index9 = pop_u32();
		def val12 = mach_readTable32(table_index0, index9);
		def eff1414 = push_Object(val12);
	}
}
def TABLE_SET() {
	def table_index0 = readImmULEB32();
	def cond152 = m_isTable64(table_index0);
	if (cond152) {
		def val3 = pop_Object();
		def index4 = pop_u64();
		def eff168 = mach_writeTable64(table_index0, index4, val3);
	} else {
		def val9 = pop_Object();
		def index10 = pop_u32();
	}
}
def CALL() {
	def index0 = readImmULEB32();
	def sig2 = m_getFuncSignature(index0);
	def target4 = i_getFunction(index0);
	def eff157 = doCall(sig2, target4);
}
def CALL_INDIRECT() {
	def sig_index0 = readImmULEB32();
	def table_index1 = readImmULEB32();
	def sig3 = m_getSignature(sig_index0);
	def cond85 = m_isTable64(table_index1);
	if (cond85) {
		def func_index6 = pop_u64();
		def target10 = i_getTableFunction64(table_index1, sig3, func_index6);
		def ret913 = doCall(sig3, target10);
		return ret913;
	} else {
		def func_index14 = pop_u32();
		def target18 = i_getTableFunction32(table_index1, sig3, func_index14);
		def ret1521 = doCall(sig3, target18);
		return ret1521;
	}
}
def RETURN() {
	def ret220 = doReturn();
	return ret220;
}
def I32_CONST() {
	def x0 = readImmILEB32();
	def eff12 = push_i32(x0);
}
def I32_ADD() {
	def x0 = pop_i32();
	def y1 = pop_i32();
	def r4 = i32.+(x0, y1);
	def eff36 = push_i32(r4);
}
def I32_SUB() {
	def x0 = pop_i32();
	def y1 = pop_i32();
	def r4 = i32.-(y1, x0);
	def eff76 = push_i32(r4);
}
def I32_EQZ() {
	def x0 = pop_i32();
	def right132 : int = 0;
	def cond73 = i32.==(x0, right132);
	if (cond73) {
		def arg94 : int = 1;
		def eff85 = push_i32(arg94);
	} else {
		def arg116 : int = 0;
		def eff107 = push_i32(arg116);
	}
}
def I32_LT_U() {
	def y0 = pop_i32();
	def x1 = pop_i32();
	def cond84 = i32.<(x1, y0);
	if (cond84) {
		def arg105 : int = 1;
		def eff96 = push_i32(arg105);
	} else {
		def arg127 : int = 0;
		def eff118 = push_i32(arg127);
	}
}
def F32_MAX() {
	def b0 = pop_f32();
	def a1 = pop_f32();
	def cond175 = float.>(a1, b0);
	if (cond175) {
	} else {
	}
	def cond148 = float.==(a1, b0);
	if (cond148) {
	} else {
	}
	def cond1111 = float.>(b0, a1);
	if (cond1111) {
	} else {
	}
	def eff913 = push_f32(a1);
}
def BR() {
	def depth0 = readImmULEB32();
	def label2 = f_getLabel(depth0);
	def eff144 = doBranch(label2);
}
def BR_IF() {
	def depth0 = readImmULEB32();
	def label2 = f_getLabel(depth0);
	def cond3 = pop_i32();
	def right105 : int = 0;
	def cond56 = i32.!=(cond3, right105);
	if (cond56) {
		def eff68 = doBranch(label2);
	} else {
		def eff89 = doFallThru();
	}
}
def BLOCK() {
	def bt0 = readImmBlockType();
	def eff102 = doBlock(bt0);
}
def LOOP() {
	def bt0 = readImmBlockType();
	def eff32 = doLoop(bt0);
}
def TRY() {
	def bt0 = readImmBlockType();
	def eff32 = doTry(bt0);
}
def IF() {
	def bt0 = readImmBlockType();
	def cond1 = pop_i32();
	def arg92 : u32 = 0;
	def label3 = f_getLabel(arg92);
	def right85 : int = 0;
	def cond36 = i32.==(cond1, right85);
	if (cond36) {
		def eff48 = doBranch(label3);
	} else {
		def eff69 = doFallThru();
	}
}
def ELSE() {
	def arg120 : u32 = 0;
	def label1 = f_getLabel(arg120);
	def eff103 = doBranch(label1);
}
def END() {
	def eff60 = doEnd();
	def cond41 = f_isAtEnd();
	if (cond41) {
		def eff52 = doReturn();
	} else {
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  DISPATCH_TABLE[Opcode.UNREACHABLE.code] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.LOCAL_GET.code] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.code] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.code] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.code] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.code] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.code] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.code] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.code] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.code] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.RETURN.code] = RETURN;
  DISPATCH_TABLE[Opcode.I32_CONST.code] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.code] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.code] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_EQZ.code] = I32_EQZ;
  DISPATCH_TABLE[Opcode.I32_LT_U.code] = I32_LT_U;
  DISPATCH_TABLE[Opcode.F32_MAX.code] = F32_MAX;
  DISPATCH_TABLE[Opcode.BR.code] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.code] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.code] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.code] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.code] = TRY;
  DISPATCH_TABLE[Opcode.IF.code] = IF;
  DISPATCH_TABLE[Opcode.ELSE.code] = ELSE;
  DISPATCH_TABLE[Opcode.END.code] = END;
  return DISPATCH_TABLE;
}

class Frame {
    var parent: Frame;
    var fp: int;
    var sidetable: Vector<(int, int)>;
    var stp: int;
    var local_types: Vector<TypeVar>; // TODO: just get ValueKinds from stack
    var codeptr: CodePtr;
    var num_rets: int;

    new(parent: Frame, fn: CBDFunction) {
        fp = stack.top - fn.args.length;
        sidetable = fn.sidetable;
        stp = 0;
        codeptr = CodePtr.new(fn.code);
        local_types = fn.locals;
        num_rets = fn.rets.length;
    }
}

class CBDFunction {
    var code: Array<byte>;
    def args: Vector<TypeVar> = Vector.new();
    def rets: Vector<TypeVar> = Vector.new();
    def locals: Vector<TypeVar> = Vector.new();
    var sidetable: Vector<(int, int)> = null;

    new(decl: FuncDecl) {
        for (param in decl.sig.params) args.put(value_type_to_type_var(param));
        for (result in decl.sig.results) rets.put(value_type_to_type_var(result));
        for (i < decl.num_locals) locals.put(TypeVar.I32); // no type?
        code = decl.orig_bytecode;
    }

    def value_type_to_type_var(vt: ValueType) -> TypeVar {
        match (vt) {
            BOTTOM => return TypeVar.Bot;
            I32 => return TypeVar.I32;
            F32 => return TypeVar.F32;
            _ => return TypeVar.Err;
        }
    }
}

var functions: Vector<CBDFunction>;

var current_frame: Frame;
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var stack: ArrayStack<Value>;

def HAS_MEM_INDEX = 0x40u8;

def readImmULEB32() -> u32 {
    return current_frame.codeptr.read_uleb32();
}

def readImmILEB32() -> i32 {
    return i32.!(current_frame.codeptr.read_uleb32());
}

def readImmULEB64() -> u64 {
    return current_frame.codeptr.read_uleb64();
}

def readImmILEB64() -> i64 {
    return i64.!(current_frame.codeptr.read_uleb64());
}

def readImmU8() -> u8 {
    return current_frame.codeptr.read1();
}

def readImmBlockType() -> () {
    def bt = current_frame.codeptr.read_BlockTypeCode();
    return ();
}

def pop_i32() -> i32 {
    match (stack.pop()) {
        I32(u) => return i32.view(u);
        _ => return 0; // TODO: fail() function
    }
}
def pop_u32() -> u32 {
    match (stack.pop()) {
        I32(u) => return u;
        _ => return 0; // TODO: fail() function
    }
}
def pop_i64() -> i64;
def pop_u64() -> u64;
def pop_f32() -> float;
def pop_f64() -> double;
def pop_v128() -> v128;
def pop_Object() -> Object;
def pop_Value(tv: TypeVar) -> Value {
    return stack.pop();
}

def push_i32(v: i32) {
    stack.push(Value.I32(u32.view(v)));
}
def push_u32(v: u32) {
    stack.push(Value.I32(v));
}
def push_i64(v: i64);
def push_u64(v: u64);
def push_f32(v: float);
def push_f64(v: double);
def push_v128(v: v128);
def push_Object(v: Object);
def push_Value(tv: TypeVar, v: Value) {
    stack.push(v);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> Value {
    return stack.elems[current_frame.fp + int.!(index)];
}
def setLocal(tv: TypeVar, index: u32, v: Value) {
    stack.elems[current_frame.fp + int.!(index)] = v;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> Value;
def setGlobal(tv: TypeVar, index: u32, v: Value);

// CBDFunction context.
def f_getLabel(depth: u32) -> Label {
    return Label(depth);
}

def f_getLocalType(index: u32) -> TypeVar {
    return current_frame.local_types[int.!(index)];
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar;
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind;
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset;
def m_isMemory64(memory_index: u32) -> bool;
def m_isTable64(memory_index: u32) -> bool;
def m_getFuncSignature(func_index: u32) -> SigDecl {
    return null; // already in CBDFunction, TODO: refactor
}
def m_getSignature(sig_index: u32) -> SigDecl;

// Instance context.
def i_getTableFunction64(table_index: u32, sig: SigDecl, func_index: u64) -> CBDFunction;
def i_getTableFunction32(table_index: u32, sig: SigDecl, func_index: u32) -> CBDFunction;
def i_getFunction(func_index: u32) -> CBDFunction {
    return functions[int.!(func_index)];
}

// Control flow.
def doCall(sig: SigDecl, target: CBDFunction) {
    def new_frame = Frame.new(current_frame, target);
    current_frame = new_frame;
    current_frame.codeptr.iterate_local_codes(push_locals);
}

def doBranch(label: Label) {
    def ste = current_frame.sidetable[current_frame.stp];
    current_frame.codeptr.at(ste.0);
    current_frame.stp = ste.1;
}

def doFallThru() {
    current_frame.stp += 1;
}

// Machine intrinsics.
def mach_readStructField_i8(obj: Object, offset: FieldOffset) -> i8;
def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
def mach_readStructField_i16(obj: Object, offset: FieldOffset) -> i16;
def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32;
def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object;

def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) -> u32;

def mach_readTable64(table_index: u32, index: u64) -> Object;
def mach_readTable32(table_index: u32, index: u32) -> Object;

def mach_writeTable64(table_index: u32, index: u64, val: Object);
def mach_writeTable32(table_index: u32, index: u32, val: Object);

// Traps.
def invalid(); // should never occur
def trapNull();
def trapUnreachable();

def doBlock(bt: ()) {
}

def doLoop(bt: ()) {
}

def doEnd() {
}

def doReturn() {
    // TODO
    def ret = stack.pop();
    stack.top = current_frame.fp;
    current_frame = current_frame.parent;
    stack.push(ret);
}

def doTry(bt: ()) {
    return;
}

def f_isAtEnd() -> bool {
    return current_frame.codeptr.pos >= current_frame.codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    System.puts("push\n");
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.I32;
        _ => tv = TypeVar.I32; // TODO
    }
    
    for (i < count) current_frame.local_types.put(tv);
}

component Interpreter {
    def init(fns: Vector<CBDFunction>, main_idx: int, args: Array<int>) {
        for (i < fns.length) {
            def fn = fns[i];
            Validator.init(fn.code, fn.locals.copy(), fn.rets.copy());
            Validator.dispatch();
            def sts = Validator.build_sidetable();
            fn.sidetable = sts.1;
            System.puts("validated ");
            System.puti(i);
            System.ln();
        }

        stack = ArrayStack<Value>.new();
        for (arg in args) stack.push(Value.I32(u32.view(arg)));
        functions = fns;
        current_frame = Frame.new(null, functions[main_idx]);
    }

    def dispatch() {
        current_frame.codeptr.iterate_local_codes(push_locals);
        while (current_frame != null && current_frame.codeptr.pos < current_frame.codeptr.data.length) {
            def op = current_frame.codeptr.read_opcode();
            // print_stack();
            // System.puts(op.mnemonic);
            // System.ln();
            DISPATCH_TABLE[op.code]();
        }
    }

    def get_stack() -> ArrayStack<Value> {
        return stack;
    }

    def print_stack() {
        System.puts("[");
        for (i < stack.top) {
            match (stack.elems[i]) {
            I32(i) => System.puti(i32.!(i));
            _ => {}
            }
            if (i < stack.top - 1) System.puts(" ");
        }
        System.puts("]\n");
    }
}
