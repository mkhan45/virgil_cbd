// GENERATED BY InterpreterGen.v3
def UNREACHABLE() {
def eff01 = trapUnreachable();
}
def LOCAL_GET() {
def index8 = readImmULEB32();
def arg79 = (index8);
def tv10 = f_getLocalType(arg79);
def arg611 = (index8);
def arg512 = (tv10);
def val13 = getLocal(arg512, arg611);
def arg414 = (val13);
def arg315 = (tv10);
def eff216 = push_Value(arg315, arg414);
}
def LOCAL_SET() {
def index23 = readImmULEB32();
def arg2224 = (index23);
def tv25 = f_getLocalType(arg2224);
def arg2126 = (tv25);
def val27 = pop_Value(arg2126);
def arg2028 = (val27);
def arg1929 = (index23);
def arg1830 = (tv25);
def eff1731 = setLocal(arg1830, arg1929, arg2028);
}
def LOCAL_TEE() {
def index41 = readImmULEB32();
def arg4042 = (index41);
def tv43 = f_getLocalType(arg4042);
def arg3944 = (tv43);
def val45 = pop_Value(arg3944);
def arg3846 = (val45);
def arg3747 = (index41);
def arg3648 = (tv43);
def eff3549 = setLocal(arg3648, arg3747, arg3846);
def arg3450 = (val45);
def arg3351 = (tv43);
def eff3252 = push_Value(arg3351, arg3450);
}
def GLOBAL_GET() {
def index59 = readImmULEB32();
def arg5860 = (index59);
def tv61 = m_getGlobalType(arg5860);
def arg5762 = (index59);
def arg5663 = (tv61);
def val64 = getGlobal(arg5663, arg5762);
def arg5565 = (val64);
def arg5466 = (tv61);
def eff5367 = push_Value(arg5466, arg5565);
}
def GLOBAL_SET() {
def index74 = readImmULEB32();
def arg7375 = (index74);
def tv76 = m_getGlobalType(arg7375);
def arg7277 = (tv76);
def val78 = pop_Value(arg7277);
def arg7179 = (val78);
def arg7080 = (index74);
def arg6981 = (tv76);
def eff6882 = setGlobal(arg6981, arg7080, arg7179);
}
def TABLE_GET() {
def table_index93 = readImmULEB32();
def arg9294 = (table_index93);
def cond8395 = m_isTable64(arg9294);
if (cond8395) {
def index96 = pop_u64();
def arg8797 = (index96);
def arg8698 = (table_index93);
def val99 = mach_readTable64(arg8698, arg8797);
def arg85100 = (val99);
def eff84101 = push_Object(arg85100);
} else {
def index102 = pop_u32();
def arg91103 = (index102);
def arg90104 = (table_index93);
def val105 = mach_readTable32(arg90104, arg91103);
def arg89106 = (val105);
def eff88107 = push_Object(arg89106);
}
}
def TABLE_SET() {
def table_index118 = readImmULEB32();
def arg117119 = (table_index118);
def cond108120 = m_isTable64(arg117119);
if (cond108120) {
def val121 = pop_Object();
def index122 = pop_u64();
def arg112123 = (val121);
def arg111124 = (index122);
def arg110125 = (table_index118);
def eff109126 = mach_writeTable64(arg110125, arg111124, arg112123);
} else {
def val127 = pop_Object();
def index128 = pop_u32();
def arg116129 = (val127);
def arg115130 = (index128);
def arg114131 = (table_index118);
def eff113132 = mach_writeTable32(arg114131, arg115130, arg116129);
}
}
def CALL() {
def index138 = readImmULEB32();
def arg137139 = (index138);
def sig140 = m_getFuncSignature(arg137139);
def arg136141 = (index138);
def target142 = i_getFunction(arg136141);
def arg135143 = (target142);
def arg134144 = (sig140);
def eff133145 = doCall(arg134144, arg135143);
}
def CALL_INDIRECT() {
def sig_index161 = readImmULEB32();
def table_index162 = readImmULEB32();
def arg160163 = (sig_index161);
def sig164 = m_getSignature(arg160163);
def arg159165 = (table_index162);
def cond146166 = m_isTable64(arg159165);
if (cond146166) {
def func_index167 = pop_u64();
def arg152168 = (func_index167);
def arg151169 = (sig164);
def arg150170 = (table_index162);
def target171 = i_getTableFunction64(arg150170, arg151169, arg152168);
def arg149172 = (target171);
def arg148173 = (sig164);
def ret147174 = doCall(arg148173, arg149172);
return ret147174;
} else {
def func_index175 = pop_u32();
def arg158176 = (func_index175);
def arg157177 = (sig164);
def arg156178 = (table_index162);
def target179 = i_getTableFunction32(arg156178, arg157177, arg158176);
def arg155180 = (target179);
def arg154181 = (sig164);
def ret153182 = doCall(arg154181, arg155180);
return ret153182;
}
}
def I32_CONST() {
def x185 = readImmILEB32();
def arg184186 = (x185);
def eff183187 = push_i32(arg184186);
}
def I32_ADD() {
def x192 = pop_i32();
def y193 = pop_i32();
def arg191194 = (y193);
def arg190195 = (x192);
def r196 = i32.+(arg190195, arg191194);
def arg189197 = (r196);
def eff188198 = push_i32(arg189197);
}
def I32_SUB() {
def x203 = pop_i32();
def y204 = pop_i32();
def arg202205 = (x203);
def arg201206 = (y204);
def r207 = i32.-(arg201206, arg202205);
def arg200208 = (r207);
def eff199209 = push_i32(arg200208);
}
def I32_EQZ() {
def x217 = pop_i32();
def left215218 = (x217);
def right216219 : int = 0;
def cond210220 = i32.==(left215218, right216219);
if (cond210220) {
def arg212221 : int = 1;
def eff211222 = push_i32(arg212221);
} else {
def arg214223 : int = 0;
def eff213224 = push_i32(arg214223);
}
}
def BR() {
def depth229 = readImmULEB32();
def arg228230 = (depth229);
def label231 = f_getLabel(arg228230);
def arg227232 = (label231);
def eff226233 = doBranch(arg227232);
def ret225234 = (void);
return ret225234;
}
def BR_IF() {
def depth243 = readImmULEB32();
def arg242244 = (depth243);
def label245 = f_getLabel(arg242244);
def cond246 = pop_i32();
def left240247 = (cond246);
def right241248 : int = 0;
def cond236249 = i32.!=(left240247, right241248);
if (cond236249) {
def arg238250 = (label245);
def eff237251 = doBranch(arg238250);
} else {
def eff239252 = doFallThru();
}
def ret235253 = (void);
return ret235253;
}
def BLOCK() {
def bt256 = readImmBlockType();
def arg255257 = (bt256);
def eff254258 = doBlock(arg255257);
}
def LOOP() {
def bt261 = readImmBlockType();
def arg260262 = (bt261);
def eff259263 = doLoop(arg260262);
}
def TRY() {
def bt266 = readImmBlockType();
def arg265267 = (bt266);
def eff264268 = doTry(arg265267);
}
def IF() {
def bt276 = readImmBlockType();
def cond277 = pop_i32();
def arg275278 : u32 = 0;
def label279 = f_getLabel(arg275278);
def left273280 = (cond277);
def right274281 : int = 0;
def cond269282 = i32.==(left273280, right274281);
if (cond269282) {
def arg271283 = (label279);
def eff270284 = doBranch(arg271283);
} else {
def eff272285 = doFallThru();
}
}
def ELSE() {
def arg288289 : u32 = 0;
def label290 = f_getLabel(arg288289);
def arg287291 = (label290);
def eff286292 = doBranch(arg287291);
}
def END() {
def eff295296 = doEnd();
def cond293297 = f_isAtEnd();
if (cond293297) {
def eff294298 = doReturn();
} else {
}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  DISPATCH_TABLE[Opcode.UNREACHABLE.code] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.LOCAL_GET.code] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.code] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.code] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.code] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.code] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.code] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.code] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.code] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.code] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.I32_CONST.code] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.code] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.code] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_EQZ.code] = I32_EQZ;
  DISPATCH_TABLE[Opcode.BR.code] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.code] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.code] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.code] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.code] = TRY;
  DISPATCH_TABLE[Opcode.IF.code] = IF;
  DISPATCH_TABLE[Opcode.ELSE.code] = ELSE;
  DISPATCH_TABLE[Opcode.END.code] = END;
  return DISPATCH_TABLE;
}

var codeptr: CodePtr;
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>; // TODO: just get ValueKinds from stack
var stack: ArrayStack<Value>;

type CtlEntry {
	case Block(end_pc: int);
	case Loop(start_pc: int, end_pc: int);
        case None;
}
var ctls: Array<CtlEntry>;
var ctl_stack: ArrayStack<int>;

// Constants
def HAS_MEM_INDEX = 0x40u8;

// Types.
type v128(low: u64, high: u64);
type Label(depth: u32);
// type Value;
// class Object { }
type TypeVar {
    case I32;
}
type FieldOffset;
class Signature { }
// class Function { }

enum FieldKind {
	U8, U16, I32, I64, F32, F64, V128, REF
}

def readImmULEB32() -> u32 {
    return codeptr.read_uleb32();
}

def readImmILEB32() -> i32 {
    return i32.!(codeptr.read_uleb32());
}

def readImmULEB64() -> u64 {
    return codeptr.read_uleb64();
}

def readImmILEB64() -> i64 {
    return i64.!(codeptr.read_uleb64());
}

def readImmU8() -> u8 {
    return codeptr.read1();
}

def readImmBlockType() -> () {
    def bt = codeptr.read_BlockTypeCode();
    return ();
}

def pop_i32() -> i32 {
    match (stack.pop()) {
        I32(u) => return i32.view(u);
        _ => return 0; // TODO: fail() function
    }
}
def pop_u32() -> u32 {
    match (stack.pop()) {
        I32(u) => return u;
        _ => return 0; // TODO: fail() function
    }
}
def pop_i64() -> i64;
def pop_u64() -> u64;
def pop_f32() -> float;
def pop_f64() -> double;
def pop_v128() -> v128;
def pop_Object() -> Object;
def pop_Value(tv: TypeVar) -> Value {
    return stack.pop();
}

def push_i32(v: i32) {
    stack.push(Value.I32(u32.view(v)));
}
def push_u32(v: u32) {
    stack.push(Value.I32(v));
}
def push_i64(v: i64);
def push_u64(v: u64);
def push_f32(v: float);
def push_f64(v: double);
def push_v128(v: v128);
def push_Object(v: Object);
def push_Value(tv: TypeVar, v: Value) {
    stack.push(v);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> Value {
    return stack.elems[index];
}
def setLocal(tv: TypeVar, index: u32, v: Value) {
    stack.elems[index] = v;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> Value;
def setGlobal(tv: TypeVar, index: u32, v: Value);

// Function context.
def f_getLabel(depth: u32) -> Label {
    return Label(depth);
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.!(index)];
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar;
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind;
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset;
def m_isMemory64(memory_index: u32) -> bool;
def m_isTable64(memory_index: u32) -> bool;
def m_getFuncSignature(func_index: u32) -> Signature;
def m_getSignature(sig_index: u32) -> Signature;

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Signature, func_index: u64) -> Function;
def i_getTableFunction32(table_index: u32, sig: Signature, func_index: u32) -> Function;
def i_getFunction(func_index: u32) -> Function;

// Control flow.
def doCall(sig: Signature, target: Function);

def doBranch(label: Label) {
    for (i < label.depth) ctl_stack.pop();
    def ctl_idx = ctl_stack.peek();
    match (ctls[ctl_idx]) {
        Block(end_pc) => {
            if (end_pc == -1) {
		skipToEnd(label.depth);
		ctls[ctl_idx] = CtlEntry.Block(codeptr.pos);
            } else {
		codeptr.at(end_pc);
	    }
	    ctl_stack.pop();
        }
	Loop(start_pc, end_pc) => {
		codeptr.at(start_pc);
	}
	None => invalid();
    }
}

def skipToEnd(depth: u32) {
    while (depth + 1 > 0) {
	def op = codeptr.read_opcode();
	if (op == Opcode.END) depth -= 1;
	codeptr.skip_immediates(op.imms);
    }
}

def doFallThru() {
}

// Machine intrinsics.
def mach_readStructField_i8(obj: Object, offset: FieldOffset) -> i8;
def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
def mach_readStructField_i16(obj: Object, offset: FieldOffset) -> i16;
def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32;
def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object;

def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) -> u32;

def mach_readTable64(table_index: u32, index: u64) -> Object;
def mach_readTable32(table_index: u32, index: u32) -> Object;

def mach_writeTable64(table_index: u32, index: u64, val: Object);
def mach_writeTable32(table_index: u32, index: u32, val: Object);

// Traps.
def invalid(); // should never occur
def trapNull();
def trapUnreachable();

def doBlock(bt: ()) {
    if (ctls[codeptr.pos] == CtlEntry.None) ctls[codeptr.pos] = CtlEntry.Block(-1);
    ctl_stack.push(codeptr.pos);
}

def doLoop(bt: ()) {
    if (ctls[codeptr.pos] == CtlEntry.None) ctls[codeptr.pos] = CtlEntry.Loop(codeptr.pos, -1);
    ctl_stack.push(codeptr.pos);
}

def doEnd() {
    def ctl_idx = ctl_stack.pop();
    match (ctls[ctl_idx]) {
        Block(end_pc) => if (end_pc == -1) ctls[ctl_idx] = CtlEntry.Block(codeptr.pos);
        Loop(start_pc, end_pc) => if (end_pc == -1) ctls[ctl_idx] = CtlEntry.Loop(start_pc, codeptr.pos);
        None => doReturn();
    }
}

def doReturn() {
    return;
}

def doTry(bt: ()) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    System.puts("push\n");
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.I32;
        _ => tv = TypeVar.I32; // TODO
    }
    
    for (i < count) local_types.put(tv);
}

component Interpreter {
    def init(code: Array<byte>, args: Array<int>) {
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        ctls = Array.new(code.length);
        for (i < code.length) ctls[i] = CtlEntry.None;
        ctl_stack = ArrayStack.new();

        for (a in args) local_types.put(TypeVar.I32);
        for (a in args) stack.push(Value.I32(u32.!(a)));
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        while (codeptr.pos < codeptr.data.length) {
            def op = codeptr.read_opcode();
	    print_stack();
            System.puts(op.mnemonic);
            System.ln();
            DISPATCH_TABLE[op.code]();
        }
    }

    def get_stack() -> ArrayStack<Value> {
        return stack;
    }

    def print_stack() {
	System.puts("[");
	for (i < stack.top) {
	    match (stack.elems[i]) {
		I32(i) => System.puti(i32.!(i));
		_ => {}
	    }
	    if (i < stack.top - 1) System.puts(" ");
	}
	System.puts("]\n");
    }
}
