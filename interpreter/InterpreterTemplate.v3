def build_dispatch_table() -> Array<void -> void> { return Array.new(0); } // dummy so this file compiles independently, replaced by processor

var codeptr: CodePtr;
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>; // TODO: just get ValueKinds from stack
var stack: ArrayStack<Value>;

var sidetable: Vector<(int, int)>; // (target_pc, target_stp)
var stp: int = 0;

// Constants
def HAS_MEM_INDEX = 0x40u8;

// Types.
// type Value;
// class Object { }
// class Function { }

def readImmULEB32() -> u32 {
    return codeptr.read_uleb32();
}

def readImmILEB32() -> i32 {
    return i32.!(codeptr.read_uleb32());
}

def readImmULEB64() -> u64 {
    return codeptr.read_uleb64();
}

def readImmILEB64() -> i64 {
    return i64.!(codeptr.read_uleb64());
}

def readImmU8() -> u8 {
    return codeptr.read1();
}

def readImmBlockType() -> () {
    def bt = codeptr.read_BlockTypeCode();
    return ();
}

def pop_i32() -> i32 {
    match (stack.pop()) {
        I32(u) => return i32.view(u);
        _ => return 0; // TODO: fail() function
    }
}
def pop_u32() -> u32 {
    match (stack.pop()) {
        I32(u) => return u;
        _ => return 0; // TODO: fail() function
    }
}
def pop_i64() -> i64;
def pop_u64() -> u64;
def pop_f32() -> float;
def pop_f64() -> double;
def pop_v128() -> v128;
def pop_Object() -> Object;
def pop_Value(tv: TypeVar) -> Value {
    return stack.pop();
}

def push_i32(v: i32) {
    stack.push(Value.I32(u32.view(v)));
}
def push_u32(v: u32) {
    stack.push(Value.I32(v));
}
def push_i64(v: i64);
def push_u64(v: u64);
def push_f32(v: float);
def push_f64(v: double);
def push_v128(v: v128);
def push_Object(v: Object);
def push_Value(tv: TypeVar, v: Value) {
    stack.push(v);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> Value {
    return stack.elems[index];
}
def setLocal(tv: TypeVar, index: u32, v: Value) {
    stack.elems[index] = v;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> Value;
def setGlobal(tv: TypeVar, index: u32, v: Value);

// Function context.
def f_getLabel(depth: u32) -> Label {
    return Label(depth);
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.!(index)];
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar;
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind;
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset;
def m_isMemory64(memory_index: u32) -> bool;
def m_isTable64(memory_index: u32) -> bool;
def m_getFuncSignature(func_index: u32) -> Signature;
def m_getSignature(sig_index: u32) -> Signature;

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Signature, func_index: u64) -> Function;
def i_getTableFunction32(table_index: u32, sig: Signature, func_index: u32) -> Function;
def i_getFunction(func_index: u32) -> Function;

// Control flow.
def doCall(sig: Signature, target: Function);

def doBranch(label: Label) {
    def ste = sidetable[stp];
    codeptr.at(ste.0);
    stp = ste.1;
}

def doFallThru() {
    stp += 1;
}

// Machine intrinsics.
def mach_readStructField_i8(obj: Object, offset: FieldOffset) -> i8;
def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
def mach_readStructField_i16(obj: Object, offset: FieldOffset) -> i16;
def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32;
def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object;

def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) -> u32;

def mach_readTable64(table_index: u32, index: u64) -> Object;
def mach_readTable32(table_index: u32, index: u32) -> Object;

def mach_writeTable64(table_index: u32, index: u64, val: Object);
def mach_writeTable32(table_index: u32, index: u32, val: Object);

// Traps.
def invalid(); // should never occur
def trapNull();
def trapUnreachable();

def doBlock(bt: ()) {
}

def doLoop(bt: ()) {
}

def doEnd() {
}

def doReturn() {
    return;
}

def doTry(bt: ()) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    System.puts("push\n");
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.I32;
        _ => tv = TypeVar.I32; // TODO
    }
    
    for (i < count) local_types.put(tv);
}

component Interpreter {
    def init(code: Array<byte>, args: Array<int>) {
        // TODO: make the interpreter run the validator
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        Validator.init(code, [TypeVar.I32, TypeVar.I32], []);
        Validator.dispatch();
        def sts = Validator.build_sidetable();
        sidetable = sts.1;
        stp = 0;

        for (a in args) local_types.put(TypeVar.I32);
        for (a in args) stack.push(Value.I32(u32.!(a)));
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        while (codeptr.pos < codeptr.data.length) {
            def op = codeptr.read_opcode();
            // print_stack();
            // System.puts(op.mnemonic);
            // System.ln();
            DISPATCH_TABLE[op.code]();
        }
    }

    def get_stack() -> ArrayStack<Value> {
        return stack;
    }

    def print_stack() {
        System.puts("[");
        for (i < stack.top) {
            match (stack.elems[i]) {
            I32(i) => System.puti(i32.!(i));
            _ => {}
            }
            if (i < stack.top - 1) System.puts(" ");
        }
        System.puts("]\n");
    }
}
